{"Asset":[{"_id":"themes/kael/source/css/component.css","path":"css/component.css","modified":false},{"_id":"themes/kael/source/css/screen.css","path":"css/screen.css","modified":false},{"_id":"themes/kael/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":false},{"_id":"themes/kael/source/fonts/OpenSans-Bold-webfont.woff","path":"fonts/OpenSans-Bold-webfont.woff","modified":false},{"_id":"themes/kael/source/fonts/OpenSans-Regular-webfont.woff","path":"fonts/OpenSans-Regular-webfont.woff","modified":false},{"_id":"themes/kael/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":false},{"_id":"themes/kael/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":false},{"_id":"themes/kael/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":false},{"_id":"themes/kael/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":false},{"_id":"themes/kael/source/js/jquery.min.js","path":"js/jquery.min.js","modified":false},{"_id":"themes/kael/source/js/lib.js","path":"js/lib.js","modified":false},{"_id":"themes/kael/source/js/main.js","path":"js/main.js","modified":false}],"Cache":[{"_id":"scaffolds/draft.md","mtime":1411976558000},{"_id":"scaffolds/page.md","mtime":1404891526000},{"_id":"scaffolds/photo.md","mtime":1404891526000},{"_id":"scaffolds/post.md","mtime":1417490197000},{"_id":"source/_drafts/Meteor-API-概览一.md","mtime":1416449476000},{"_id":"source/_drafts/Meteor中的hot-push实现方式.md","mtime":1418182159000},{"_id":"source/_posts/Express中Can-t-set-headers-after-they-are-sent错误的解决方法.md","mtime":1417100715000},{"_id":"source/_posts/Extending-Meteor-Accounts.md","mtime":1416449476000},{"_id":"source/_posts/Ionic中使用emulate-android报错的问题.md","mtime":1422172627000},{"_id":"source/_posts/Makefile.md","mtime":1412572984000},{"_id":"source/_posts/Meteor中settings的设置方法.md","mtime":1412836898000},{"_id":"source/_posts/Meteor中由于活性数据造成多次调用的问题.md","mtime":1416449897000},{"_id":"source/_posts/Redis的操作方法.md","mtime":1416925446000},{"_id":"source/_posts/git命令小记.md","mtime":1412572978000},{"_id":"source/_posts/js中获取时间戳的方法.md","mtime":1417490180000},{"_id":"source/_posts/npm网速慢的解决办法.md","mtime":1411958621000},{"_id":"source/_posts/关于在Meteor中写自定义登录需要注意的地方.md","mtime":1413213673000},{"_id":"source/_posts/在Meteor的registerHelper中需要注意的坑.md","mtime":1417492423000},{"_id":"source/_posts/简单解析formidable-s-API.md","mtime":1416449476000},{"_id":"source/about/index.md","mtime":1411958734000},{"_id":"themes/kael/LICENSE","mtime":1411899186000},{"_id":"themes/kael/README.md","mtime":1411957879000},{"_id":"themes/kael/_config.yml","mtime":1411957864000},{"_id":"themes/kael/layout/archive.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/category.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/index.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/layout.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/page.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/post.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/tag.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/kael/after_all.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/kael/footer.ejs","mtime":1412569711000},{"_id":"themes/kael/layout/kael/head.ejs","mtime":1412571448000},{"_id":"themes/kael/layout/kael/index.ejs","mtime":1416477311000},{"_id":"themes/kael/layout/kael/post.ejs","mtime":1411899186000},{"_id":"themes/kael/source/css/component.css","mtime":1416477317000},{"_id":"themes/kael/source/css/screen.css","mtime":1416477683000},{"_id":"themes/kael/source/fonts/FontAwesome.otf","mtime":1411899186000},{"_id":"themes/kael/source/fonts/OpenSans-Bold-webfont.woff","mtime":1411899186000},{"_id":"themes/kael/source/fonts/OpenSans-Regular-webfont.woff","mtime":1411899186000},{"_id":"themes/kael/source/fonts/fontawesome-webfont.eot","mtime":1411899186000},{"_id":"themes/kael/source/fonts/fontawesome-webfont.svg","mtime":1411899186000},{"_id":"themes/kael/source/fonts/fontawesome-webfont.ttf","mtime":1411899186000},{"_id":"themes/kael/source/fonts/fontawesome-webfont.woff","mtime":1411899186000},{"_id":"themes/kael/source/js/jquery.min.js","mtime":1411899186000},{"_id":"themes/kael/source/js/lib.js","mtime":1411899186000},{"_id":"themes/kael/source/js/main.js","mtime":1416477327000},{"_id":"source/_posts/iron-router用法解析.md","mtime":1423470527000},{"_id":"source/_posts/学习React-Native.md","mtime":1428546408000}],"Category":[{"name":"技术","_id":"tpesbjcpw3rq03xi","posts":["2blnnjbg6o36n36c","ndg6p32uuc9ed3q6","v5ll2yfx48er8kyd","q75acnxoa2cesbrc","mtchkwlzmdsep8qp","5uy8qggc5tdz1nxc","bpldp3guq4p74ura","m17k6eq0hg0mjgim","w7nq8dq23qy97nji","5zrq8i6lwcqnl7at","eftm7vi9m5gz3zh9","owk8suio5ywvn503","z5rdaz2onsnwq5pm","94hkdiuffvygixux"]}],"Page":[{"title":"个人简介","date":1411919729000,"content":"<p>非著名前端工程师幼年体，亚洲善待前端组织（PETE）QQ群主</p>\n","source":"about/index.md","raw":"title: 个人简介\ndate: 2014-09-28 23:55:29\n---\n\n非著名前端工程师幼年体，亚洲善待前端组织（PETE）QQ群主","updated":1411958734000,"path":"about/index.html","excerpt":"","_id":"8398rfe8rgpfztsz","comments":true,"layout":"page"}],"Post":[{"title":"Ionic中使用emulate android报错的问题","categories":["tpesbjcpw3rq03xi"],"date":1422112722000,"tags":["sl0aau0kcybo43px","5jnnh3psj7laaui1"],"content":"<p>我在预览Android应用的时候，发现不能正常预览，弹出错误，提示类似让我创建一个Android服务之类的错误，提示我使用<code>android create avd --name &lt;yourname&gt; --target &lt;targetId&gt;</code>来创建</p>\n<p>在百度了之后，发现创建方法如下：</p>\n<figure class=\"highlight\"><pre><div class=\"line\">$ Android <span class=\"keyword\">list</span> targets</div></pre></figure>\n\n<p>会列出如下列表：</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"comment\">----------</span></div><div class=\"line\">id: <span class=\"number\">1</span> <span class=\"keyword\">or</span> <span class=\"string\">\"android-8\"</span></div><div class=\"line\">     Name: Android <span class=\"number\">2.2</span></div><div class=\"line\">     <span class=\"keyword\">Type</span>: Platform</div><div class=\"line\">     API level: <span class=\"number\">8</span></div><div class=\"line\">     Revision: <span class=\"number\">3</span></div><div class=\"line\">     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WVGA800 (<span class=\"keyword\">default</span>), WVGA854</div><div class=\"line\"> Tag/ABIs : <span class=\"keyword\">default</span>/armeabi</div><div class=\"line\"><span class=\"comment\">----------</span></div><div class=\"line\">id: <span class=\"number\">2</span> <span class=\"keyword\">or</span> <span class=\"string\">\"android-19\"</span></div><div class=\"line\">     Name: Android <span class=\"number\">4.4</span><span class=\"number\">.2</span></div><div class=\"line\">     <span class=\"keyword\">Type</span>: Platform</div><div class=\"line\">     API level: <span class=\"number\">19</span></div><div class=\"line\">     Revision: <span class=\"number\">3</span></div><div class=\"line\">     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (<span class=\"keyword\">default</span>), WVGA854, WXGA720, WXGA800, WXGA800-<span class=\"number\">7</span><span class=\"keyword\">in</span></div><div class=\"line\"> Tag/ABIs : <span class=\"keyword\">default</span>/armeabi-v7a</div><div class=\"line\"><span class=\"comment\">----------</span></div><div class=\"line\">id: <span class=\"number\">3</span> <span class=\"keyword\">or</span> <span class=\"string\">\"Google Inc.:Google APIs:8\"</span></div><div class=\"line\">     Name: Google APIs</div><div class=\"line\">     <span class=\"keyword\">Type</span>: Add-<span class=\"keyword\">On</span></div><div class=\"line\">     Vendor: Google Inc.</div><div class=\"line\">     Revision: <span class=\"number\">2</span></div><div class=\"line\">     Description: Android + Google APIs</div><div class=\"line\">     Based <span class=\"keyword\">on</span> Android <span class=\"number\">2.2</span> (API level <span class=\"number\">8</span>)</div><div class=\"line\">     Libraries:</div><div class=\"line\">      * com.google.android.maps (maps.jar)</div><div class=\"line\">          API <span class=\"keyword\">for</span> Google Maps</div><div class=\"line\">     Skins: HVGA, WQVGA400, QVGA, WVGA800 (<span class=\"keyword\">default</span>), WQVGA432, WVGA854</div><div class=\"line\"> Tag/ABIs : <span class=\"keyword\">default</span>/armeabi</div></pre></figure>\n\n<p>然后选好你需要的Android平台版本，记住id，创建即可，我使用的是平台版本为4.4.2的，即targetid为2</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"comment\">$</span> <span class=\"comment\">android</span> <span class=\"comment\">create</span> <span class=\"comment\">avd</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">name</span> <span class=\"comment\">test</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">target</span> <span class=\"comment\">2</span></div></pre></figure>\n\n<p>创建好后，再使用</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"variable\">$ </span>ionic emulate android</div></pre></figure>\n\n<p>即可成功预览咯<br>PS:安卓虚拟机可真是卡顿的没话说啊。。。</p>\n","source":"_posts/Ionic中使用emulate-android报错的问题.md","raw":"title: Ionic中使用emulate android报错的问题\ncategories: 技术\ndate: 2015-01-24 23:18:42\ntags: [hybird app, ionic]\n---\n\n我在预览Android应用的时候，发现不能正常预览，弹出错误，提示类似让我创建一个Android服务之类的错误，提示我使用`android create avd --name <yourname> --target <targetId>`来创建\n\n在百度了之后，发现创建方法如下：\n\n```\n$ Android list targets\n```\n\n会列出如下列表：\n\n```\n----------\nid: 1 or \"android-8\"\n     Name: Android 2.2\n     Type: Platform\n     API level: 8\n     Revision: 3\n     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WVGA800 (default), WVGA854\n Tag/ABIs : default/armeabi\n----------\nid: 2 or \"android-19\"\n     Name: Android 4.4.2\n     Type: Platform\n     API level: 19\n     Revision: 3\n     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (default), WVGA854, WXGA720, WXGA800, WXGA800-7in\n Tag/ABIs : default/armeabi-v7a\n----------\nid: 3 or \"Google Inc.:Google APIs:8\"\n     Name: Google APIs\n     Type: Add-On\n     Vendor: Google Inc.\n     Revision: 2\n     Description: Android + Google APIs\n     Based on Android 2.2 (API level 8)\n     Libraries:\n      * com.google.android.maps (maps.jar)\n          API for Google Maps\n     Skins: HVGA, WQVGA400, QVGA, WVGA800 (default), WQVGA432, WVGA854\n Tag/ABIs : default/armeabi\n```\n\n然后选好你需要的Android平台版本，记住id，创建即可，我使用的是平台版本为4.4.2的，即targetid为2\n\n```\n$ android create avd --name test --target 2\n```\n\n创建好后，再使用\n\n```\n$ ionic emulate android\n```\n即可成功预览咯\nPS:安卓虚拟机可真是卡顿的没话说啊。。。","slug":"Ionic中使用emulate-android报错的问题","updated":1422172627000,"excerpt":"","_id":"2blnnjbg6o36n36c","comments":true,"layout":"post","photos":[],"link":""},{"title":"Express中Can't set headers after they are sent错误的解决方法","date":1417100460000,"categories":["tpesbjcpw3rq03xi"],"tags":["wdwsejiu177doh12","79oh9zi6efbuiccj"],"content":"<p>我在实际开发中遇到了<code>express</code>的如下报错</p>\n<figure class=\"highlight\"><pre><div class=\"line\">Error: Can't <span class=\"operator\"><span class=\"keyword\">set</span> headers <span class=\"keyword\">after</span> they <span class=\"keyword\">are</span> sent.</span></div><div class=\"line\">  <span class=\"keyword\">at</span> ServerResponse.OutgoingMessage.setHeader (_http_outgoing.js:<span class=\"number\">331</span>:<span class=\"number\">11</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> ServerResponse.res.setHeader (/Users/phishing/Documents/Phishing/test/drifter/node_modules/express/node_modules/<span class=\"keyword\">connect</span>/lib/patch.js:<span class=\"number\">134</span>:<span class=\"number\">22</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> ServerResponse.res.<span class=\"keyword\">set</span>.res.header (/Users/phishing/Documents/Phishing/test/drifter/node_modules/express/lib/response.js:<span class=\"number\">583</span>:<span class=\"number\">10</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> ServerResponse.res.send (/Users/phishing/Documents/Phishing/test/drifter/node_modules/express/lib/response.js:<span class=\"number\">144</span>:<span class=\"number\">12</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> ServerResponse.res.json (/Users/phishing/Documents/Phishing/test/drifter/node_modules/express/lib/response.js:<span class=\"number\">225</span>:<span class=\"number\">15</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> /Users/phishing/Documents/Phishing/test/drifter/app.coffee:<span class=\"number\">41</span>:<span class=\"number\">16</span></div><div class=\"line\">  <span class=\"keyword\">at</span> Promise.&lt;anonymous&gt; (/Users/phishing/Documents/Phishing/test/drifter/models/mongodb.coffee:<span class=\"number\">25</span>:<span class=\"number\">3</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> Promise.&lt;anonymous&gt; (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mpromise/lib/promise.js:<span class=\"number\">177</span>:<span class=\"number\">8</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> Promise.EventEmitter.emit (<span class=\"keyword\">events</span>.js:<span class=\"number\">110</span>:<span class=\"number\">17</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> Promise.emit (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mpromise/lib/promise.js:<span class=\"number\">84</span>:<span class=\"number\">38</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> Promise.fulfill (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mpromise/lib/promise.js:<span class=\"number\">97</span>:<span class=\"number\">20</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> handleSave (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/lib/model.js:<span class=\"number\">133</span>:<span class=\"number\">13</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> /Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/lib/utils.js:<span class=\"number\">408</span>:<span class=\"number\">16</span></div><div class=\"line\">  <span class=\"keyword\">at</span> /Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/collection/core.js:<span class=\"number\">125</span>:<span class=\"number\">9</span></div><div class=\"line\">  <span class=\"keyword\">at</span> /Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/db.js:<span class=\"number\">1157</span>:<span class=\"number\">7</span></div><div class=\"line\">  <span class=\"keyword\">at</span> /Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/db.js:<span class=\"number\">1890</span>:<span class=\"number\">9</span></div><div class=\"line\">  <span class=\"keyword\">at</span> <span class=\"keyword\">Server</span>.Base._callHandler (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/<span class=\"keyword\">connection</span>/base.js:<span class=\"number\">448</span>:<span class=\"number\">41</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> /Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/<span class=\"keyword\">connection</span>/<span class=\"keyword\">server</span>.js:<span class=\"number\">481</span>:<span class=\"number\">18</span></div><div class=\"line\">  <span class=\"keyword\">at</span> [object Object].MongoReply.parseBody (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/responses/mongo_reply.js:<span class=\"number\">68</span>:<span class=\"number\">5</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> [object Object].&lt;anonymous&gt; (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/<span class=\"keyword\">connection</span>/<span class=\"keyword\">server</span>.js:<span class=\"number\">439</span>:<span class=\"number\">20</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> [object Object].EventEmitter.emit (<span class=\"keyword\">events</span>.js:<span class=\"number\">107</span>:<span class=\"number\">17</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> [object Object].&lt;anonymous&gt; (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/<span class=\"keyword\">connection</span>/connection_pool.js:<span class=\"number\">201</span>:<span class=\"number\">13</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> [object Object].EventEmitter.emit (<span class=\"keyword\">events</span>.js:<span class=\"number\">110</span>:<span class=\"number\">17</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> Socket.&lt;anonymous&gt; (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/<span class=\"keyword\">connection</span>/<span class=\"keyword\">connection</span>.js:<span class=\"number\">439</span>:<span class=\"number\">22</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> Socket.EventEmitter.emit (<span class=\"keyword\">events</span>.js:<span class=\"number\">107</span>:<span class=\"number\">17</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> readableAddChunk (_stream_readable.js:<span class=\"number\">159</span>:<span class=\"number\">16</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> Socket.Readable.push (_stream_readable.js:<span class=\"number\">126</span>:<span class=\"number\">10</span>)</div><div class=\"line\">  <span class=\"keyword\">at</span> TCP.onread (net.js:<span class=\"number\">514</span>:<span class=\"number\">20</span>)</div></pre></figure>\n\n<p>经查找后发现，是因为我在路由中触发了两次<code>res.json</code></p>\n<p>在<code>nodeJs实战</code>一书中的132页，在使用mongo储存瓶子之后，原作者只<code>return</code>出了<code>mongodb.save</code>函数，导致最后的<code>res.json(callback)</code>仍然执行，触发了上述错误</p>\n<p>解决办法很简单，只需在<code>mongodb.save</code>前面加一个’return’即可</p>\n","source":"_posts/Express中Can-t-set-headers-after-they-are-sent错误的解决方法.md","raw":"title: \"Express中Can't set headers after they are sent错误的解决方法\"\ndate: 2014-11-27 23:01:00\ncategories: 技术\ntags: [nodejs, express]\n---\n我在实际开发中遇到了`express`的如下报错\n```\nError: Can't set headers after they are sent.\n  at ServerResponse.OutgoingMessage.setHeader (_http_outgoing.js:331:11)\n  at ServerResponse.res.setHeader (/Users/phishing/Documents/Phishing/test/drifter/node_modules/express/node_modules/connect/lib/patch.js:134:22)\n  at ServerResponse.res.set.res.header (/Users/phishing/Documents/Phishing/test/drifter/node_modules/express/lib/response.js:583:10)\n  at ServerResponse.res.send (/Users/phishing/Documents/Phishing/test/drifter/node_modules/express/lib/response.js:144:12)\n  at ServerResponse.res.json (/Users/phishing/Documents/Phishing/test/drifter/node_modules/express/lib/response.js:225:15)\n  at /Users/phishing/Documents/Phishing/test/drifter/app.coffee:41:16\n  at Promise.<anonymous> (/Users/phishing/Documents/Phishing/test/drifter/models/mongodb.coffee:25:3)\n  at Promise.<anonymous> (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mpromise/lib/promise.js:177:8)\n  at Promise.EventEmitter.emit (events.js:110:17)\n  at Promise.emit (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mpromise/lib/promise.js:84:38)\n  at Promise.fulfill (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mpromise/lib/promise.js:97:20)\n  at handleSave (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/lib/model.js:133:13)\n  at /Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/lib/utils.js:408:16\n  at /Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/collection/core.js:125:9\n  at /Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/db.js:1157:7\n  at /Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/db.js:1890:9\n  at Server.Base._callHandler (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/base.js:448:41)\n  at /Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/server.js:481:18\n  at [object Object].MongoReply.parseBody (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/responses/mongo_reply.js:68:5)\n  at [object Object].<anonymous> (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/server.js:439:20)\n  at [object Object].EventEmitter.emit (events.js:107:17)\n  at [object Object].<anonymous> (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/connection_pool.js:201:13)\n  at [object Object].EventEmitter.emit (events.js:110:17)\n  at Socket.<anonymous> (/Users/phishing/Documents/Phishing/test/drifter/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/connection.js:439:22)\n  at Socket.EventEmitter.emit (events.js:107:17)\n  at readableAddChunk (_stream_readable.js:159:16)\n  at Socket.Readable.push (_stream_readable.js:126:10)\n  at TCP.onread (net.js:514:20)\n```\n经查找后发现，是因为我在路由中触发了两次`res.json`\n\n在`nodeJs实战`一书中的132页，在使用mongo储存瓶子之后，原作者只`return`出了`mongodb.save`函数，导致最后的`res.json(callback)`仍然执行，触发了上述错误\n\n解决办法很简单，只需在`mongodb.save`前面加一个'return'即可","slug":"Express中Can-t-set-headers-after-they-are-sent错误的解决方法","updated":1417100715000,"excerpt":"","_id":"ndg6p32uuc9ed3q6","comments":true,"layout":"post","photos":[],"link":""},{"title":"扩展Meteor的用户系统","date":1413008069000,"categories":["tpesbjcpw3rq03xi"],"tags":["i2s34gm2iixl2i7j"],"content":"<h1 id=\"简要说明\">简要说明</h1>\n<p>本文是翻译MeteorHacks的一篇关于Meteor中Accounts的文章,原文见<a href=\"https://meteorhacks.com/extending-meteor-accounts.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n<h1 id=\"正文\">正文</h1>\n<p>Meteor有一个非常好的用户认证系统，称之为<a href=\"http://docs.meteor.com/#accounts_api\" target=\"_blank\" rel=\"external\">Accounts</a>。这个认证系统不仅仅为用密码、facebook、twitter和其他平台提供了强大的方法，还因为其与Meteor的核心服务相关联，从而提供高级别的安全。</p>\n<p>好的，但是如果你想添加一个自定义的验证方法呢？Meteor没有给你足够的信息让你这么做。所以我(原作者)开始研究<a href=\"http://goo.gl/PfIvj\" target=\"_blank\" rel=\"external\">Meteor Accounts system</a>的源代码。我发现作者的代码写的十分优雅，同时实现一个自定义的认证方式也非常简单。接下来我们就来说说这个。</p>\n<p>在这个教程里，我将会为我们的Meteor App来创建一个用于管理的自定义认证系统。但这个系统不是一个正式的实现方式，仅仅可以用来演示如何添加自定义认证。</p>\n<h1 id=\"首先，创建一个简单的应用\">首先，创建一个简单的应用</h1>\n<ul>\n<li>用<code>meteor create admin</code>来创建一个Meteor应用</li>\n<li>用<code>meteor add accounts-ui</code>来添加<code>accounts-ui</code>包</li>\n<li>用下面的代码来替换掉<code>admin.html</code>中的代码<br>添加<code>loginButtons</code>来调用<code>accounts-ui</code>包</li>\n</ul>\n<figure class=\"highlight html\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">title</span>&gt;</span>admin<span class=\"tag\">&lt;/<span class=\"title\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">body</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  {{&gt; hello}}</div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">template</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"hello\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">h1</span>&gt;</span>Hello World!<span class=\"tag\">&lt;/<span class=\"title\">h1</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  {{greeting}}</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  {{&gt; loginButtons}}</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"button\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"Click\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">template</span>&gt;</span></div></pre></figure>\n\n<p>现在，当你启动你的应用的时候，你将会看到如下的信息。（不要在意红色的字）<br><img src=\"http://phishingw.qiniudn.com/GNOR8BK.png\" alt=\"初始界面\"></p>\n<h1 id=\"添加登录的处理方式\">添加登录的处理方式</h1>\n<p>现在，我们需要为我们的管理认证系统注册一个登录的方法。下面是一个创建在<code>server/admin.js</code>的服务端函数。</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Accounts.registerLoginHandler(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(loginRequest)</span> </span>{</div><div class=\"line\">  <span class=\"comment\">//Meteor中有多个登录模块 </span></div><div class=\"line\">  <span class=\"comment\">//一个登录的请求需要通过所有的这些登录模块来寻找它所需要的模块</span></div><div class=\"line\">  <span class=\"comment\">//所以，在我们这个登录模块中，我们只需要考虑登录的请求中含有admin字段请求</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(!loginRequest.admin) {</div><div class=\"line\">  \t<span class=\"comment\">//如果不含有admin字段，则return出去</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">  }</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//这里是我们的认证逻辑</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(loginRequest.password != <span class=\"string\">'admin-password'</span>) {</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">  }</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//如果不存在管理帐号，则创建一个，并获取到userId</span></div><div class=\"line\">  <span class=\"keyword\">var</span> userId = <span class=\"literal\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> user = Meteor.users.findOne({username: <span class=\"string\">'admin'</span>});</div><div class=\"line\">  <span class=\"keyword\">if</span>(!user) {</div><div class=\"line\">    userId = Meteor.users.insert({username: <span class=\"string\">'admin'</span>});</div><div class=\"line\">  } <span class=\"keyword\">else</span> {</div><div class=\"line\">    userId = user._id;</div><div class=\"line\">  }</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//发送登录者的userId</span></div><div class=\"line\">  <span class=\"keyword\">return</span> {</div><div class=\"line\">    id: userId</div><div class=\"line\">  }</div><div class=\"line\">});</div></pre></figure>\n\n<p>现在简单的登录函数已经写完了</p>\n<h1 id=\"添加客户端的登录函数\">添加客户端的登录函数</h1>\n<p>新建<code>client/admin.js</code>文件，将以下代码写入其中：</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Meteor.loginAsAdmin = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(password, callback)</span> </span>{</div><div class=\"line\">  <span class=\"comment\">//新建一个带有admin:true的请求，从而让我们的登录模块来处理这个请求</span></div><div class=\"line\">  <span class=\"keyword\">var</span> loginRequest = {admin: <span class=\"literal\">true</span>, password: password};</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//发送登录的请求</span></div><div class=\"line\">  Accounts.callLoginMethod({</div><div class=\"line\">    methodArguments: [loginRequest],</div><div class=\"line\">    userCallback: callback</div><div class=\"line\">  });</div><div class=\"line\">};</div></pre></figure>\n\n<p>现在我们就能添加我们的管理员登录系统。在浏览器的console界面中调用<code>loginAsAdmin</code>方法，然后你会看到你已经登录进去了</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\"><span class=\"comment\">//在浏览器的console中调用</span></div><div class=\"line\">Meteor.loginAsAdmin(<span class=\"string\">'admin-password'</span>);</div></pre></figure>\n\n<p><img src=\"http://phishingw.qiniudn.com/jEa7ZJW.png\" alt=\"登录成功\"></p>\n<h1 id=\"刷新浏览器\">刷新浏览器</h1>\n<p>当你刷新你的浏览器的时候，你会发现你并没有继续处于登录状态。那是因为你没有在登录的时候没有添加一个记录token的功能。<br>用以下的代码来更新<code>server/admin.js</code></p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Accounts.registerLoginHandler(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(loginRequest)</span> </span>{</div><div class=\"line\">  <span class=\"keyword\">if</span>(!loginRequest.admin) {</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">  }</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(loginRequest.password != <span class=\"string\">'admin-password'</span>) {</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">  }</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">var</span> userId = <span class=\"literal\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> user = Meteor.users.findOne({username: <span class=\"string\">'admin'</span>});</div><div class=\"line\">  <span class=\"keyword\">if</span>(!user) {</div><div class=\"line\">    userId = Meteor.users.insert({username: <span class=\"string\">'admin'</span>});</div><div class=\"line\">  } <span class=\"keyword\">else</span> {</div><div class=\"line\">    userId = user._id;</div><div class=\"line\">  }</div><div class=\"line\">  <span class=\"comment\">//以上代码无变化</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//创建一个token并记录在user中</span></div><div class=\"line\">  <span class=\"keyword\">var</span> stampedToken = Accounts._generateStampedLoginToken();</div><div class=\"line\">  <span class=\"comment\">//在Meteor 0.7.x中就已经添加了对hash算法的支持 </span></div><div class=\"line\">  <span class=\"comment\">//在Meteor 0.7.x之前的版本你就不需要做这样的处理</span></div><div class=\"line\">  <span class=\"keyword\">var</span> hashStampedToken = Accounts._hashStampedToken(stampedToken);</div><div class=\"line\">  </div><div class=\"line\">  Meteor.users.update(userId, </div><div class=\"line\">    {$push: {<span class=\"string\">'services.resume.loginTokens'</span>: hashStampedToken}}</div><div class=\"line\">  );</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//把token和userId一并返回</span></div><div class=\"line\">  <span class=\"keyword\">return</span> {</div><div class=\"line\">    id: userId,</div><div class=\"line\">    token: stampedToken.token</div><div class=\"line\">  }</div><div class=\"line\">});</div></pre></figure>\n\n<p>这段代码就能解决刷新后自动退出登录状态的问题了</p>\n<h1 id=\"总结\">总结</h1>\n<p>现在我们来总结一下我们已经做的事情</p>\n<ul>\n<li>我们尝试着为我们的应用做了一个管理登录系统</li>\n<li>为其添加了登录模块</li>\n<li>添加了一个客户端的登录方法</li>\n<li>添加了刷新token</li>\n</ul>\n<p>你可以从Github上来下载<a href=\"https://github.com/arunoda/meteor-custom-authentication-system\" target=\"_blank\" rel=\"external\">源代码</a><br>这样是不是很简单的就能为Meteor应用添加一个新的认证系统货方法了？：）</p>\n","source":"_posts/Extending-Meteor-Accounts.md","raw":"title: 扩展Meteor的用户系统\ndate: 2014-10-11 14:14:29\ncategories: 技术\ntags: Meteor\n---\n\n简要说明\n=======================\n本文是翻译MeteorHacks的一篇关于Meteor中Accounts的文章,原文见[这里](https://meteorhacks.com/extending-meteor-accounts.html)\n\n正文\n======================\nMeteor有一个非常好的用户认证系统，称之为[Accounts](http://docs.meteor.com/#accounts_api)。这个认证系统不仅仅为用密码、facebook、twitter和其他平台提供了强大的方法，还因为其与Meteor的核心服务相关联，从而提供高级别的安全。\n\n好的，但是如果你想添加一个自定义的验证方法呢？Meteor没有给你足够的信息让你这么做。所以我(原作者)开始研究[Meteor Accounts system](http://goo.gl/PfIvj)的源代码。我发现作者的代码写的十分优雅，同时实现一个自定义的认证方式也非常简单。接下来我们就来说说这个。\n\n在这个教程里，我将会为我们的Meteor App来创建一个用于管理的自定义认证系统。但这个系统不是一个正式的实现方式，仅仅可以用来演示如何添加自定义认证。\n\n首先，创建一个简单的应用\n=======================\n* 用`meteor create admin`来创建一个Meteor应用\n* 用`meteor add accounts-ui`来添加`accounts-ui`包\n* 用下面的代码来替换掉`admin.html`中的代码\n添加`loginButtons`来调用`accounts-ui`包\n```html\n<head>\n  <title>admin</title>\n</head>\n<body>\n{% raw %}\n  {{> hello}}\n{% endraw /%}\n</body>\n<template name=\"hello\">\n  <h1>Hello World!</h1>\n{% raw %}\n  {{greeting}}\n{% endraw /%}\n{% raw %}\n  {{> loginButtons}}\n{% endraw /%}\n  <input type=\"button\" value=\"Click\" />\n</template>\n```\n现在，当你启动你的应用的时候，你将会看到如下的信息。（不要在意红色的字）\n![初始界面](http://phishingw.qiniudn.com/GNOR8BK.png)\n\n添加登录的处理方式\n====================\n现在，我们需要为我们的管理认证系统注册一个登录的方法。下面是一个创建在`server/admin.js`的服务端函数。\n```javascript\nAccounts.registerLoginHandler(function(loginRequest) {\n  //Meteor中有多个登录模块 \n  //一个登录的请求需要通过所有的这些登录模块来寻找它所需要的模块\n  //所以，在我们这个登录模块中，我们只需要考虑登录的请求中含有admin字段请求\n  if(!loginRequest.admin) {\n  \t//如果不含有admin字段，则return出去\n    return undefined;\n  }\n\n  //这里是我们的认证逻辑\n  if(loginRequest.password != 'admin-password') {\n    return null;\n  }\n  \n  //如果不存在管理帐号，则创建一个，并获取到userId\n  var userId = null;\n  var user = Meteor.users.findOne({username: 'admin'});\n  if(!user) {\n    userId = Meteor.users.insert({username: 'admin'});\n  } else {\n    userId = user._id;\n  }\n\n  //发送登录者的userId\n  return {\n    id: userId\n  }\n});\n```\n\n现在简单的登录函数已经写完了\n\n添加客户端的登录函数\n=================\n新建`client/admin.js`文件，将以下代码写入其中：\n```javascript\nMeteor.loginAsAdmin = function(password, callback) {\n  //新建一个带有admin:true的请求，从而让我们的登录模块来处理这个请求\n  var loginRequest = {admin: true, password: password};\n\n  //发送登录的请求\n  Accounts.callLoginMethod({\n    methodArguments: [loginRequest],\n    userCallback: callback\n  });\n};\n```\n现在我们就能添加我们的管理员登录系统。在浏览器的console界面中调用`loginAsAdmin`方法，然后你会看到你已经登录进去了\n```javascript\n//在浏览器的console中调用\nMeteor.loginAsAdmin('admin-password');\n```\n![登录成功](http://phishingw.qiniudn.com/jEa7ZJW.png)\n\n刷新浏览器\n================\n当你刷新你的浏览器的时候，你会发现你并没有继续处于登录状态。那是因为你没有在登录的时候没有添加一个记录token的功能。\n用以下的代码来更新`server/admin.js`\n```javascript\nAccounts.registerLoginHandler(function(loginRequest) {\n  if(!loginRequest.admin) {\n    return undefined;\n  }\n\n  if(loginRequest.password != 'admin-password') {\n    return null;\n  }\n  \n  var userId = null;\n  var user = Meteor.users.findOne({username: 'admin'});\n  if(!user) {\n    userId = Meteor.users.insert({username: 'admin'});\n  } else {\n    userId = user._id;\n  }\n  //以上代码无变化\n\n  //创建一个token并记录在user中\n  var stampedToken = Accounts._generateStampedLoginToken();\n  //在Meteor 0.7.x中就已经添加了对hash算法的支持 \n  //在Meteor 0.7.x之前的版本你就不需要做这样的处理\n  var hashStampedToken = Accounts._hashStampedToken(stampedToken);\n  \n  Meteor.users.update(userId, \n    {$push: {'services.resume.loginTokens': hashStampedToken}}\n  );\n\n  //把token和userId一并返回\n  return {\n    id: userId,\n    token: stampedToken.token\n  }\n});\n```\n这段代码就能解决刷新后自动退出登录状态的问题了\n\n总结\n===========================\n现在我们来总结一下我们已经做的事情\n* 我们尝试着为我们的应用做了一个管理登录系统\n* 为其添加了登录模块\n* 添加了一个客户端的登录方法\n* 添加了刷新token\n\n你可以从Github上来下载[源代码](https://github.com/arunoda/meteor-custom-authentication-system)\n这样是不是很简单的就能为Meteor应用添加一个新的认证系统货方法了？：）\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Extending-Meteor-Accounts","updated":1416449476000,"excerpt":"","_id":"v5ll2yfx48er8kyd","comments":true,"layout":"post","photos":[],"link":""},{"title":"Makefile的简单应用","date":1412347958000,"categories":["tpesbjcpw3rq03xi"],"tags":["wdwsejiu177doh12","oypeex4xmny41osd","8pxwx1ea09hdyd99"],"content":"<h1 id=\"需求分析\">需求分析</h1>\n<p>在编写nodejs的过程中，我们经常会遇到clone一个项目后，先要键入<code>npm install</code>来安装依赖，然后运行<code>gulp</code>(因为我觉得gulp的语法很简单，所以我只会gulp，还没研究过grunt)来生成相关编译后的静态文件，再使用<code>node app</code>来运行项目</p>\n<p>这种情况如果只是一次还好，但由于nodejs在每次项目文件更改过之后，需要中断进程，然后重启进程，这个过程如果循环很多遍，相信很多人都会疯掉，虽然后类似<code>supervisor</code>之类的小工具能解决问题，<code>grunt</code>也有相应的插件能解决这个问题，例如文件改动，页面自动刷新等等，但是我这里提供了一种另外的解决方案</p>\n<h1 id=\"Makefile简介\">Makefile简介</h1>\n<p>第一次看到<code>Makefile</code>是在别人的项目中，发现很好用，主要是能少打好多个字，看了下，发现里面内容也很简单</p>\n<p>下面这个是我写的一个Makefile文件里面的内容</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"operator\"><span class=\"keyword\">install</span> : <span class=\"keyword\">all</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">all</span> :</div><div class=\"line\">\tnpm <span class=\"keyword\">install</span></div><div class=\"line\">\tgulp scripts</div><div class=\"line\">\tnode app</div></pre></figure>\n\n<p>用法很简单吧，你只需要把你要运行的命令写在all下面就好了</p>\n","source":"_posts/Makefile.md","raw":"title: Makefile的简单应用\ndate: 2014-10-03 22:52:38\ncategories: 技术\ntags: [nodejs, npm, linux]\n---\n\n需求分析\n================\n在编写nodejs的过程中，我们经常会遇到clone一个项目后，先要键入``npm install``来安装依赖，然后运行``gulp``(因为我觉得gulp的语法很简单，所以我只会gulp，还没研究过grunt)来生成相关编译后的静态文件，再使用``node app``来运行项目\n\n这种情况如果只是一次还好，但由于nodejs在每次项目文件更改过之后，需要中断进程，然后重启进程，这个过程如果循环很多遍，相信很多人都会疯掉，虽然后类似``supervisor``之类的小工具能解决问题，``grunt``也有相应的插件能解决这个问题，例如文件改动，页面自动刷新等等，但是我这里提供了一种另外的解决方案\n\nMakefile简介\n================\n\n第一次看到``Makefile``是在别人的项目中，发现很好用，主要是能少打好多个字，看了下，发现里面内容也很简单\n\n下面这个是我写的一个Makefile文件里面的内容\n```\ninstall : all\n\nall :\n\tnpm install\n\tgulp scripts\n\tnode app\n```\n\n用法很简单吧，你只需要把你要运行的命令写在all下面就好了\n","slug":"Makefile","updated":1412572984000,"excerpt":"","_id":"q75acnxoa2cesbrc","comments":true,"layout":"post","photos":[],"link":""},{"title":"Meteor中settings的设置方法","date":1412836257000,"categories":["tpesbjcpw3rq03xi"],"tags":["i2s34gm2iixl2i7j"],"content":"<p>在Meteor的实际开发中，可能会针对不同的服务器做相关的设置，但如果每次都是改源代码会显得很麻烦，也容易出错，于是Meteor.settings就横空出世了</p>\n<p>Meteor.settings的设置很简单</p>\n<p>首先在更目录下新建一个<code>settings.json</code>文件</p>\n<p>在文件中写入</p>\n<figure class=\"highlight json\"><pre><div class=\"line\">{</div><div class=\"line\">\t\"<span class=\"attribute\">foo</span>\": <span class=\"value\"><span class=\"string\">\"bar\"</span></span></div><div class=\"line\">}</div></pre></figure>\n\n<p>然后在命令行中输入<code>meteor --settings settings.json</code>来启动项目，或者通过<code>meteor deploy --settings settings.json</code>来部署项目</p>\n<p>这样在Meteor的server端中键入<code>console.log(Meteor.settings.foo)</code>就会返回’bar’</p>\n<p>需要注意的就是，在<code>settings.json</code>中，一定要用严格的json格式，不能使用单引号，不然会出现<code>parse error reading settings file</code>的错误</p>\n<p>例如我正在写一个关于ldap的配置，具体信息如下</p>\n<figure class=\"highlight json\"><pre><div class=\"line\">{</div><div class=\"line\">\t\"<span class=\"attribute\">ldap</span>\": <span class=\"value\">{</span></div><div class=\"line\">\t    \"<span class=\"attribute\">url</span>\": <span class=\"value\"><span class=\"string\">\"ldap://my.ldapserver.com\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">base</span>\": <span class=\"value\"><span class=\"string\">\"ou=people,dc=mydomain\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">timeout</span>\": <span class=\"value\"><span class=\"number\">10000</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">bindDn</span>\": <span class=\"value\"><span class=\"string\">\"cn=admin,dc=mydomain\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">bindSecret</span>\": <span class=\"value\"><span class=\"string\">\"thesecret\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">filter</span>\": <span class=\"value\"><span class=\"string\">\"(&(uid=%uid)(objectClass=inetOrgPerson))\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">scope</span>\": <span class=\"value\"><span class=\"string\">\"one\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">nameAttribute</span>\": <span class=\"value\"><span class=\"string\">\"displayName\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">mailAttribute</span>\": <span class=\"value\"><span class=\"string\">\"mail\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">forceUsername</span>\": <span class=\"value\"><span class=\"literal\">true</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">throwError</span>\": <span class=\"value\"><span class=\"literal\">true</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">supportedServices</span>\": <span class=\"value\">[<span class=\"string\">\"cas\"</span>]</span></div><div class=\"line\">  \t}</div><div class=\"line\">}</div></pre></figure>\n\n<p>这样写之后，你用<code>meteor --settings settings.json</code>来运行，打印你的<code>Meteor.settings</code>就能看见相关设置的信息了</p>\n","source":"_posts/Meteor中settings的设置方法.md","raw":"title: Meteor中settings的设置方法\ndate: 2014-10-09 14:30:57\ncategories: 技术\ntags: Meteor\n---\n\n在Meteor的实际开发中，可能会针对不同的服务器做相关的设置，但如果每次都是改源代码会显得很麻烦，也容易出错，于是Meteor.settings就横空出世了\n\nMeteor.settings的设置很简单\n\n首先在更目录下新建一个`settings.json`文件\n\n在文件中写入\n\n```json\n{\n\t\"foo\": \"bar\"\n}\n```\n\n然后在命令行中输入`meteor --settings settings.json`来启动项目，或者通过`meteor deploy --settings settings.json`来部署项目\n\n这样在Meteor的server端中键入`console.log(Meteor.settings.foo)`就会返回'bar'\n\n需要注意的就是，在`settings.json`中，一定要用严格的json格式，不能使用单引号，不然会出现`parse error reading settings file`的错误\n\n例如我正在写一个关于ldap的配置，具体信息如下\n```json\n{\n\t\"ldap\": {\n\t    \"url\": \"ldap://my.ldapserver.com\",\n\t    \"base\": \"ou=people,dc=mydomain\",\n\t    \"timeout\": 10000,\n\t    \"bindDn\": \"cn=admin,dc=mydomain\",\n\t    \"bindSecret\": \"thesecret\",\n\t    \"filter\": \"(&(uid=%uid)(objectClass=inetOrgPerson))\",\n\t    \"scope\": \"one\",\n\t    \"nameAttribute\": \"displayName\",\n\t    \"mailAttribute\": \"mail\",\n\t    \"forceUsername\": true,\n\t    \"throwError\": true,\n\t    \"supportedServices\": [\"cas\"]\n  \t}\n}\n```\n\n这样写之后，你用`meteor --settings settings.json`来运行，打印你的`Meteor.settings`就能看见相关设置的信息了\n\n","slug":"Meteor中settings的设置方法","updated":1412836898000,"excerpt":"","_id":"mtchkwlzmdsep8qp","comments":true,"layout":"post","photos":[],"link":""},{"title":"git命令小记","date":1412310505000,"categories":["tpesbjcpw3rq03xi"],"tags":["kht1av0nt14rakkn"],"content":"<h3 id=\"简要说明\">简要说明</h3>\n<p>刚刚接触git，一直都不会用git，因为之前用的都是svn，目前正在学习nodejs，所以想把写的练习同步到github上，就查了下用法</p>\n<h3 id=\"初始化\">初始化</h3>\n<p>git的初始化是</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"variable\">$ </span>git init</div></pre></figure>\n\n<p>这样系统就在当前目录生成了一个<code>.git</code>目录</p>\n<p>首次使用<code>git</code>你可能还需要配置一下<code>git</code></p>\n<p>你可以使用以下命令来配置你<code>git</code>的常用昵称和邮箱</p>\n<figure class=\"highlight\"><pre><div class=\"line\">$ git config --global <span class=\"literal\">user</span>.name <span class=\"string\">\"Phishing\"</span></div><div class=\"line\">$ git config --global <span class=\"literal\">user</span>.email <span class=\"string\">\"yourname@xxx.com\"</span></div></pre></figure>\n\n<h3 id=\"添加文件\">添加文件</h3>\n<p>初始化以后，就需要开始添加你想要添加的文件进入git仓库了</p>\n<p>你可以使用<code>git add</code>这个命令来添加<br>例如</p>\n<figure class=\"highlight\"><pre><div class=\"line\">$ git <span class=\"built_in\">add</span> *.js</div><div class=\"line\">$ git <span class=\"built_in\">add</span> *.html</div><div class=\"line\">$ git <span class=\"built_in\">add</span> package.json</div><div class=\"line\">$ git <span class=\"built_in\">add</span> README.md</div></pre></figure>\n\n<p>这样你就把以上文件加入到了git监控的目录里面了</p>\n<p>当然在实际工作中，有些文件是不需要提交到git的</p>\n<p>你可以在当前目录中新建一个<code>.gitignore</code>文件</p>\n<p>在里面添加你不需要监控的文件</p>\n<figure class=\"highlight\"><pre><div class=\"line\">node_modules/           <span class=\"comment\">//node的包，不需要传上去，文件夹后面加一个/，代表该文件夹被忽略</span></div><div class=\"line\">/test\t\t\t\t\t<span class=\"comment\">//代表根目录下的test文件被忽略</span></div><div class=\"line\">.DS_store \t\t\t\t<span class=\"comment\">//代表.DS_store被忽略</span></div></pre></figure>\n\n<p>查看当前git的状态可以使用<code>git status</code></p>\n<p>如果你没有添加上面的.gitignore的话，输入<code>git status</code>，git就会用红色高亮告诉你这几个文件是没有被加入git的监控中的，如果需要就使用<code>git add &lt;filename&gt;</code>来添加<br>加了.gitignore后，就不会再提示</p>\n<h3 id=\"提交代码\">提交代码</h3>\n<p>文件添加成功后，就可以开始提交代码了</p>\n<p>可以使用<code>git commit</code>来提交代码到git仓库中</p>\n<p>如果之间键入<code>git commit</code>会提示你没有添加提交massage，你可以在弹出的文件中键入提交信息，然后退出编辑器，即自动提交</p>\n<p>当然这样可能会有点麻烦，所以你可以利用<code>git commit -m &#39;your massage&#39;</code>来在命令行中直接写入提交的信息</p>\n<p>输入完后，git就会告诉你你当前git仓库里面的状态了</p>\n<p>刚刚开始接触git的时候，我每改动一个文件，然后用<code>git status</code>来查看过后发现，我需要再键入一遍<code>git add &lt;filename&gt;</code>才能提交，这让我感觉非常麻烦</p>\n<p>后来我终于知道有个快捷方式了，就是<code>git commit -a -m &#39;your massage&#39;</code>，这样就能跳过<code>git add</code>这个步骤了，当然这样有好有坏，我就不细说了</p>\n<h3 id=\"提交代码到远程仓库\">提交代码到远程仓库</h3>\n<p>提交代码到远程仓库时，你首先得新建一个<code>ssh key</code>，<a href=\"https://help.github.com/articles/generating-ssh-keys/\" target=\"_blank\" rel=\"external\">具体方法在这里</a></p>\n<p>弄好ssh key之后，就可以使用</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"variable\">$ </span>git remote origin <span class=\"symbol\">git:</span>/<span class=\"regexp\">/your_github_address/your</span>_repositores_name.git</div></pre></figure>\n\n<p>来定义远程仓库的地址了</p>\n<p>定义好之后就能使用</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"variable\">$ </span>git push</div></pre></figure>\n\n<p>来提交代码到远程仓库了</p>\n<p>如果你是第一次提交代码，系统会提示你使用</p>\n<figure class=\"highlight\"><pre><div class=\"line\">$ git <span class=\"keyword\">push</span> --<span class=\"keyword\">set</span>-upstream origin master</div></pre></figure>\n\n<p>来提交代码</p>\n<p>以后你就可以修改代码然后使用</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"variable\">$ </span>git commit -a -m <span class=\"string\">'your massage'</span></div><div class=\"line\"><span class=\"variable\">$ </span>git push</div></pre></figure>\n\n<p>来提交你的代码了：）</p>\n<h3 id=\"最后\">最后</h3>\n<p>以上就是我这刚刚接触git的小白了解到的一些git的基本操作了，如有错误，还请指出</p>\n<p>谢谢观看【捂脸下台</p>\n","source":"_posts/git命令小记.md","raw":"title: git命令小记\ndate: 2014-10-03 12:28:25\ncategories: 技术\ntags: git\n---\n\n###简要说明\n\n刚刚接触git，一直都不会用git，因为之前用的都是svn，目前正在学习nodejs，所以想把写的练习同步到github上，就查了下用法\n\n###初始化\ngit的初始化是\n```\n$ git init\n```\n这样系统就在当前目录生成了一个``.git``目录\n\n首次使用``git``你可能还需要配置一下``git``\n\n你可以使用以下命令来配置你``git``的常用昵称和邮箱\n```\n$ git config --global user.name \"Phishing\"\n$ git config --global user.email \"yourname@xxx.com\"\n```\n\n###添加文件\n\n初始化以后，就需要开始添加你想要添加的文件进入git仓库了\n\n你可以使用``git add``这个命令来添加\n例如\n```\n$ git add *.js\n$ git add *.html\n$ git add package.json\n$ git add README.md\n```\n\n这样你就把以上文件加入到了git监控的目录里面了\n\n当然在实际工作中，有些文件是不需要提交到git的\n\n你可以在当前目录中新建一个``.gitignore``文件\n\n在里面添加你不需要监控的文件\n```\nnode_modules/           //node的包，不需要传上去，文件夹后面加一个/，代表该文件夹被忽略\n/test\t\t\t\t\t//代表根目录下的test文件被忽略\n.DS_store \t\t\t\t//代表.DS_store被忽略\n```\n查看当前git的状态可以使用``git status``\n\n如果你没有添加上面的.gitignore的话，输入``git status``，git就会用红色高亮告诉你这几个文件是没有被加入git的监控中的，如果需要就使用``git add <filename>``来添加\n加了.gitignore后，就不会再提示\n\n###提交代码\n\n文件添加成功后，就可以开始提交代码了\n\n可以使用``git commit``来提交代码到git仓库中\n\n如果之间键入``git commit``会提示你没有添加提交massage，你可以在弹出的文件中键入提交信息，然后退出编辑器，即自动提交\n\n当然这样可能会有点麻烦，所以你可以利用``git commit -m 'your massage'``来在命令行中直接写入提交的信息\n\n输入完后，git就会告诉你你当前git仓库里面的状态了\n\n刚刚开始接触git的时候，我每改动一个文件，然后用``git status``来查看过后发现，我需要再键入一遍``git add <filename>``才能提交，这让我感觉非常麻烦\n\n后来我终于知道有个快捷方式了，就是``git commit -a -m 'your massage'``，这样就能跳过``git add``这个步骤了，当然这样有好有坏，我就不细说了\n\n###提交代码到远程仓库\n\n提交代码到远程仓库时，你首先得新建一个``ssh key``，[具体方法在这里](https://help.github.com/articles/generating-ssh-keys/)\n\n弄好ssh key之后，就可以使用\n\n```\n$ git remote origin git://your_github_address/your_repositores_name.git\n```\n\n来定义远程仓库的地址了\n\n定义好之后就能使用\n```\n$ git push\n```\n来提交代码到远程仓库了\n\n如果你是第一次提交代码，系统会提示你使用\n```\n$ git push --set-upstream origin master\n```\n来提交代码\n\n以后你就可以修改代码然后使用\n```\n$ git commit -a -m 'your massage'\n$ git push\n```\n来提交你的代码了：）\n\n###最后\n\n以上就是我这刚刚接触git的小白了解到的一些git的基本操作了，如有错误，还请指出\n\n谢谢观看【捂脸下台\n\n\n\n\n\n\n","slug":"git命令小记","updated":1412572978000,"excerpt":"","_id":"5uy8qggc5tdz1nxc","comments":true,"layout":"post","photos":[],"link":""},{"title":"Meteor中由于活性数据造成多次调用的问题","date":1416414246000,"categories":[],"tags":[],"content":"<p>在<code>meteor</code>的开发中，我们经常会遇到一个模板的<code>helper</code>中的某一个变量的计算过程中，使用了活性数据，例如<code>Collection.find</code>、<code>Session.get(&#39;key&#39;)</code>之类的。由于这些值默认为活性数据，也就是说当这些值发生改变的时候，引用了活性数据的变量就会重新计算一次，如若这个变量逻辑很复杂，则是一件十分耗性能的事情。</p>\n<p>举个例子，我在开发过程中遇到过这种情况。我前台算好了一个数据，然后去后台订阅数据回来，我在某一个模板的<code>helper</code>中使用了<code>find</code>去查询取回来的数据，但是我的订阅是动态订阅的，所以我这个<code>helper</code>就会不停的重复调用，甚至是在我数据还没订阅回来，在订阅过程中就在不停的调用，这显然是不太好的地方。</p>\n<p>例如这样的代码</p>\n<p>client/subscribe.js</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\"><span class=\"keyword\">var</span> day = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getDay()</div><div class=\"line\">Meteor.subscribe(<span class=\"string\">'comment'</span>, {</div><div class=\"line\">\tday: day</div><div class=\"line\">})</div></pre></figure>\n\n<p>client/view/index.html</p>\n<figure class=\"highlight html\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">template</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"index\"</span>&gt;</span></div><div class=\"line\">\t{{#each comments}}</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>{{content}}<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></div><div class=\"line\">\t{{/each}}</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">template</span>&gt;</span></div></pre></figure>\n\n<p>client/view/index.js</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Template.index.helper({</div><div class=\"line\">\t<span class=\"string\">'comments'</span>: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> Comment.find()</div><div class=\"line\">\t}</div><div class=\"line\">})</div></pre></figure>\n\n<p>如果这个时候很不巧，正好刚刚过了零点，那么订阅的数据就会发生更改，导致<code>Comment.find</code>的值在不停的更改，就会不断触发<code>comments</code>这个<code>helper</code>在<strong>订阅数据还未完成</strong>的情况下重复计算，为了解决这样的情况，我使用了以下方法：</p>\n<p>client/subscribe.js</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\"><span class=\"keyword\">var</span> day = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getDay()</div><div class=\"line\">Meteor.isReady = Meteor.subscribe(<span class=\"string\">'comment'</span>, {</div><div class=\"line\">\tday: day</div><div class=\"line\">})</div></pre></figure>\n\n<p>client/view/index.js</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Template.index.helper({</div><div class=\"line\">\t<span class=\"string\">'comments'</span>: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">\t\t<span class=\"comment\">// 用订阅的ready状态来判断是否返回，避免正在订阅的时候也继续计算</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(Meteor.isReady.ready()) {</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> Comment.find()</div><div class=\"line\">\t\t}</div><div class=\"line\">\t}</div><div class=\"line\">})</div></pre></figure>\n\n<p>这个例子太简单，而且也没有很形象的重现出遇到的问题，在实际开发过程中，代码远比这要复杂的多，而且我在使用中会出现<code>Meteor.isReady.ready()</code>状态值不是实时更新，或没有活性跟踪的情况，不知道这是因为bug还是我的代码写的有问题，在不得已的情况下，我把上述例子改成了</p>\n<p>client/subscribe.js</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\"><span class=\"keyword\">var</span> day = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getDay()</div><div class=\"line\">Meteor.isReady = Meteor.subscribe(<span class=\"string\">'comment'</span>, {</div><div class=\"line\">\tday: day</div><div class=\"line\">})</div><div class=\"line\">Session.set(<span class=\"string\">'isReady'</span>,Meteor.isReady.ready())</div></pre></figure>\n\n<p>client/view/index.js</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Template.index.helper({</div><div class=\"line\">\t<span class=\"string\">'comments'</span>: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">\t\t<span class=\"comment\">// 用订阅的ready状态来判断是否返回，避免正在订阅的时候也继续计算</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(Session.get(<span class=\"string\">'isReady'</span>)) {</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> Comment.find()</div><div class=\"line\">\t\t}</div><div class=\"line\">\t}</div><div class=\"line\">})</div></pre></figure>\n\n<p>Meteor在实际开发中还是有很多问题，有无数的坑等着去填(╯‵□′)╯︵┻━┻</p>\n","source":"_posts/Meteor中由于活性数据造成多次调用的问题.md","raw":"title: Meteor中由于活性数据造成多次调用的问题\ndate: 2014-11-20 00:24:06\ncategories:\ntags:\n---\n在`meteor`的开发中，我们经常会遇到一个模板的`helper`中的某一个变量的计算过程中，使用了活性数据，例如`Collection.find`、`Session.get('key')`之类的。由于这些值默认为活性数据，也就是说当这些值发生改变的时候，引用了活性数据的变量就会重新计算一次，如若这个变量逻辑很复杂，则是一件十分耗性能的事情。\n\n举个例子，我在开发过程中遇到过这种情况。我前台算好了一个数据，然后去后台订阅数据回来，我在某一个模板的`helper`中使用了`find`去查询取回来的数据，但是我的订阅是动态订阅的，所以我这个`helper`就会不停的重复调用，甚至是在我数据还没订阅回来，在订阅过程中就在不停的调用，这显然是不太好的地方。\n\n例如这样的代码\n\nclient/subscribe.js\n```javascript\nvar day = new Date().getDay()\nMeteor.subscribe('comment', {\n\tday: day\n})\n```\n\nclient/view/index.html\n```html\n<template name=\"index\">\n\t{% raw %}{{#each comments}}{% endraw %}\n\t\t{% raw %}<p>{{content}}</p>{% endraw %}\n\t{% raw %}{{/each}}{% endraw %}\n</template>\n```\n\nclient/view/index.js\n```javascript\nTemplate.index.helper({\n\t'comments': function() {\n\t\treturn Comment.find()\n\t}\n})\n```\n\n如果这个时候很不巧，正好刚刚过了零点，那么订阅的数据就会发生更改，导致`Comment.find`的值在不停的更改，就会不断触发`comments`这个`helper`在**订阅数据还未完成**的情况下重复计算，为了解决这样的情况，我使用了以下方法：\n\nclient/subscribe.js\n```javascript\nvar day = new Date().getDay()\nMeteor.isReady = Meteor.subscribe('comment', {\n\tday: day\n})\n```\n\nclient/view/index.js\n```javascript\nTemplate.index.helper({\n\t'comments': function() {\n\t\t// 用订阅的ready状态来判断是否返回，避免正在订阅的时候也继续计算\n\t\tif(Meteor.isReady.ready()) {\n\t\t\treturn Comment.find()\n\t\t}\n\t}\n})\n```\n\n这个例子太简单，而且也没有很形象的重现出遇到的问题，在实际开发过程中，代码远比这要复杂的多，而且我在使用中会出现`Meteor.isReady.ready()`状态值不是实时更新，或没有活性跟踪的情况，不知道这是因为bug还是我的代码写的有问题，在不得已的情况下，我把上述例子改成了\n\nclient/subscribe.js\n```javascript\nvar day = new Date().getDay()\nMeteor.isReady = Meteor.subscribe('comment', {\n\tday: day\n})\nSession.set('isReady',Meteor.isReady.ready())\n```\n\nclient/view/index.js\n```javascript\nTemplate.index.helper({\n\t'comments': function() {\n\t\t// 用订阅的ready状态来判断是否返回，避免正在订阅的时候也继续计算\n\t\tif(Session.get('isReady')) {\n\t\t\treturn Comment.find()\n\t\t}\n\t}\n})\n```\n\nMeteor在实际开发中还是有很多问题，有无数的坑等着去填(╯‵□′)╯︵┻━┻\n\n","slug":"Meteor中由于活性数据造成多次调用的问题","updated":1416449897000,"excerpt":"","_id":"en1q9lj64hgu01cb","comments":true,"layout":"post","photos":[],"link":""},{"title":"Redis的操作方法(转载)","date":1416925268000,"categories":["tpesbjcpw3rq03xi"],"tags":["qjgr2r65ycm2eidc","xx9i2su2pjsm4s2l"],"content":"<h2 id=\"Redis命令总结\">Redis命令总结</h2>\n<p>转载自(<a href=\"http://blog.lunastudio.cn/?p=153)[http://blog.lunastudio.cn/?p=153\" target=\"_blank\" rel=\"external\">http://blog.lunastudio.cn/?p=153)[http://blog.lunastudio.cn/?p=153</a>]<br>Redis提供了丰富的命令（command）对数据库和各种数据类型进行操作，这些command可以在Linux终端使用。在编程时，比如使用Redis 的Java语言包，这些命令都有对应的方法，比如上面例子中使用的sadd方法，就是对集合操作中的SADD命令。下面将Redis提供的命令做一总结。</p>\n<h1 id=\"连接操作相关的命令\">连接操作相关的命令</h1>\n<p>   quit：关闭连接（connection）</p>\n<p>   auth：简单密码认证</p>\n<p>对value操作的命令<br>=========<br>   exists(key)：确认一个key是否存在</p>\n<p>   del(key)：删除一个key</p>\n<p>   type(key)：返回值的类型</p>\n<p>   keys(pattern)：返回满足给定pattern的所有key</p>\n<p>   randomkey：随机返回key空间的一个key</p>\n<p>   rename(oldname, newname)：将key由oldname重命名为newname，若newname存在则删除newname表示的key</p>\n<p>   dbsize：返回当前数据库中key的数目</p>\n<p>   expire：设定一个key的活动时间（s）</p>\n<p>   ttl：获得一个key的活动时间</p>\n<p>   select(index)：按索引查询</p>\n<p>   move(key, dbindex)：将当前数据库中的key转移到有dbindex索引的数据库</p>\n<p>   flushdb：删除当前选择数据库中的所有key</p>\n<p>   flushall：删除所有数据库中的所有key</p>\n<h1 id=\"对String操作的命令\">对String操作的命令</h1>\n<p>   set(key, value)：给数据库中名称为key的string赋予值value</p>\n<p>   get(key)：返回数据库中名称为key的string的value</p>\n<p>   getset(key, value)：给名称为key的string赋予上一次的value</p>\n<p>   mget(key1, key2,…, key N)：返回库中多个string（它们的名称为key1，key2…）的value</p>\n<p>   setnx(key, value)：如果不存在名称为key的string，则向库中添加string，名称为key，值为value</p>\n<p>   setex(key, time, value)：向库中添加string（名称为key，值为value）同时，设定过期时间time</p>\n<p>   mset(key1, value1, key2, value2,…key N, value N)：同时给多个string赋值，名称为key i的string赋值value i</p>\n<p>   msetnx(key1, value1, key2, value2,…key N, value N)：如果所有名称为key i的string都不存在，则向库中添加string，名称key i赋值为value i</p>\n<p>   incr(key)：名称为key的string增1操作</p>\n<p>   incrby(key, integer)：名称为key的string增加integer</p>\n<p>   decr(key)：名称为key的string减1操作</p>\n<p>   decrby(key, integer)：名称为key的string减少integer</p>\n<p>   append(key, value)：名称为key的string的值附加value</p>\n<p>   substr(key, start, end)：返回名称为key的string的value的子串</p>\n<h1 id=\"对List操作的命令\">对List操作的命令</h1>\n<p>   rpush(key, value)：在名称为key的list尾添加一个值为value的元素</p>\n<p>   lpush(key, value)：在名称为key的list头添加一个值为value的 元素</p>\n<p>   llen(key)：返回名称为key的list的长度</p>\n<p>   lrange(key, start, end)：返回名称为key的list中start至end之间的元素（下标从0开始，下同）</p>\n<p>   ltrim(key, start, end)：截取名称为key的list，保留start至end之间的元素</p>\n<p>   lindex(key, index)：返回名称为key的list中index位置的元素</p>\n<p>   lset(key, index, value)：给名称为key的list中index位置的元素赋值为value</p>\n<p>   lrem(key, count, value)：删除count个名称为key的list中值为value的元素。count为0，删除所有值为value的元素，count&gt;0从头至尾删除count个值为value的元素，count&lt;0从尾到头删除|count|个值为value的元素。</p>\n<p>   lpop(key)：返回并删除名称为key的list中的首元素</p>\n<p>   rpop(key)：返回并删除名称为key的list中的尾元素</p>\n<p>   blpop(key1, key2,… key N, timeout)：lpop命令的block版本。即当timeout为0时，若遇到名称为key i的list不存在或该list为空，则命令结束。如果timeout&gt;0，则遇到上述情况时，等待timeout秒，如果问题没有解决，则对key i+1开始的list执行pop操作。</p>\n<p>   brpop(key1, key2,… key N, timeout)：rpop的block版本。参考上一命令。</p>\n<p>   rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</p>\n<h1 id=\"对Set操作的命令\">对Set操作的命令</h1>\n<p>   sadd(key, member)：向名称为key的set中添加元素member</p>\n<p>   srem(key, member) ：删除名称为key的set中的元素member</p>\n<p>   spop(key) ：随机返回并删除名称为key的set中一个元素</p>\n<p>   smove(srckey, dstkey, member) ：将member元素从名称为srckey的集合移到名称为dstkey的集合</p>\n<p>   scard(key) ：返回名称为key的set的基数</p>\n<p>   sismember(key, member) ：测试member是否是名称为key的set的元素</p>\n<p>   sinter(key1, key2,…key N) ：求交集</p>\n<p>   sinterstore(dstkey, key1, key2,…key N) ：求交集并将交集保存到dstkey的集合</p>\n<p>   sunion(key1, key2,…key N) ：求并集</p>\n<p>   sunionstore(dstkey, key1, key2,…key N) ：求并集并将并集保存到dstkey的集合</p>\n<p>   sdiff(key1, key2,…key N) ：求差集</p>\n<p>   sdiffstore(dstkey, key1, key2,…key N) ：求差集并将差集保存到dstkey的集合</p>\n<p>   smembers(key) ：返回名称为key的set的所有元素</p>\n<p>   srandmember(key) ：随机返回名称为key的set的一个元素</p>\n<h1 id=\"对zset（sorted_set）操作的命令\">对zset（sorted set）操作的命令</h1>\n<p>   zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。</p>\n<p>   zrem(key, member) ：删除名称为key的zset中的元素member</p>\n<p>   zincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment</p>\n<p>   zrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”</p>\n<p>   zrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”</p>\n<p>   zrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素</p>\n<p>   zrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素</p>\n<p>   zrangebyscore(key, min, max)：返回名称为key的zset中score &gt;= min且score &lt;= max的所有元素</p>\n<p>   zcard(key)：返回名称为key的zset的基数</p>\n<p>   zscore(key, element)：返回名称为key的zset中元素element的score</p>\n<p>   zremrangebyrank(key, min, max)：删除名称为key的zset中rank &gt;= min且rank &lt;= max的所有元素</p>\n<p>   zremrangebyscore(key, min, max) ：删除名称为key的zset中score &gt;= min且score &lt;= max的所有元素</p>\n<p>   zunionstore / zinterstore(dstkeyN, key1,…,keyN, WEIGHTS w1,…wN, AGGREGATE SUM|MIN|MAX)：对N个zset求并集和交集，并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。如果没有提供WEIGHT，默认为1。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行SUM运算的值，而MIN和MAX是指，结果集合中元素的score是所有集合对应元素中最小值和最大值。</p>\n<h1 id=\"对Hash操作的命令\">对Hash操作的命令</h1>\n<p>   hset(key, field, value)：向名称为key的hash中添加元素field&lt;—&gt;value</p>\n<p>   hget(key, field)：返回名称为key的hash中field对应的value</p>\n<p>   hmget(key, field1, …,field N)：返回名称为key的hash中field i对应的value</p>\n<p>   hmset(key, field1, value1,…,field N, value N)：向名称为key的hash中添加元素field i&lt;—&gt;value i</p>\n<p>   hincrby(key, field, integer)：将名称为key的hash中field的value增加integer</p>\n<p>   hexists(key, field)：名称为key的hash中是否存在键为field的域</p>\n<p>   hdel(key, field)：删除名称为key的hash中键为field的域</p>\n<p>   hlen(key)：返回名称为key的hash中元素个数</p>\n<p>   hkeys(key)：返回名称为key的hash中所有键</p>\n<p>   hvals(key)：返回名称为key的hash中所有键对应的value</p>\n<p>   hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value</p>\n<h1 id=\"持久化\">持久化</h1>\n<p>   save：将数据同步保存到磁盘</p>\n<p>   bgsave：将数据异步保存到磁盘</p>\n<p>   lastsave：返回上次成功将数据保存到磁盘的Unix时戳</p>\n<p>   shundown：将数据同步保存到磁盘，然后关闭服务</p>\n<h1 id=\"远程服务控制\">远程服务控制</h1>\n<p>   info：提供服务器的信息和统计</p>\n<p>   monitor：实时转储收到的请求</p>\n<p>   slaveof：改变复制策略设置</p>\n<p>   config：在运行时配置Redis服务器</p>\n","source":"_posts/Redis的操作方法.md","raw":"title: Redis的操作方法(转载)\ndate: 2014-11-25 22:21:08\ncategories: [技术]\ntags: [数据库, Redis]\n---\n\nRedis命令总结\n-----------\n转载自(http://blog.lunastudio.cn/?p=153)[http://blog.lunastudio.cn/?p=153]\nRedis提供了丰富的命令（command）对数据库和各种数据类型进行操作，这些command可以在Linux终端使用。在编程时，比如使用Redis 的Java语言包，这些命令都有对应的方法，比如上面例子中使用的sadd方法，就是对集合操作中的SADD命令。下面将Redis提供的命令做一总结。\n\n连接操作相关的命令\n=========\n   quit：关闭连接（connection）\n\n   auth：简单密码认证\n\n对value操作的命令\n=========\n   exists(key)：确认一个key是否存在\n\n   del(key)：删除一个key\n\n   type(key)：返回值的类型\n\n   keys(pattern)：返回满足给定pattern的所有key\n\n   randomkey：随机返回key空间的一个key\n\n   rename(oldname, newname)：将key由oldname重命名为newname，若newname存在则删除newname表示的key\n\n   dbsize：返回当前数据库中key的数目\n\n   expire：设定一个key的活动时间（s）\n\n   ttl：获得一个key的活动时间\n\n   select(index)：按索引查询\n\n   move(key, dbindex)：将当前数据库中的key转移到有dbindex索引的数据库\n\n   flushdb：删除当前选择数据库中的所有key\n\n   flushall：删除所有数据库中的所有key\n\n对String操作的命令\n======\n   set(key, value)：给数据库中名称为key的string赋予值value\n\n   get(key)：返回数据库中名称为key的string的value\n\n   getset(key, value)：给名称为key的string赋予上一次的value\n\n   mget(key1, key2,…, key N)：返回库中多个string（它们的名称为key1，key2…）的value\n\n   setnx(key, value)：如果不存在名称为key的string，则向库中添加string，名称为key，值为value\n\n   setex(key, time, value)：向库中添加string（名称为key，值为value）同时，设定过期时间time\n\n   mset(key1, value1, key2, value2,…key N, value N)：同时给多个string赋值，名称为key i的string赋值value i\n\n   msetnx(key1, value1, key2, value2,…key N, value N)：如果所有名称为key i的string都不存在，则向库中添加string，名称key i赋值为value i\n\n   incr(key)：名称为key的string增1操作\n\n   incrby(key, integer)：名称为key的string增加integer\n\n   decr(key)：名称为key的string减1操作\n\n   decrby(key, integer)：名称为key的string减少integer\n\n   append(key, value)：名称为key的string的值附加value\n\n   substr(key, start, end)：返回名称为key的string的value的子串\n\n对List操作的命令\n=======\n   rpush(key, value)：在名称为key的list尾添加一个值为value的元素\n\n   lpush(key, value)：在名称为key的list头添加一个值为value的 元素\n\n   llen(key)：返回名称为key的list的长度\n\n   lrange(key, start, end)：返回名称为key的list中start至end之间的元素（下标从0开始，下同）\n\n   ltrim(key, start, end)：截取名称为key的list，保留start至end之间的元素\n\n   lindex(key, index)：返回名称为key的list中index位置的元素\n\n   lset(key, index, value)：给名称为key的list中index位置的元素赋值为value\n\n   lrem(key, count, value)：删除count个名称为key的list中值为value的元素。count为0，删除所有值为value的元素，count>0从头至尾删除count个值为value的元素，count<0从尾到头删除|count|个值为value的元素。\n\n   lpop(key)：返回并删除名称为key的list中的首元素\n\n   rpop(key)：返回并删除名称为key的list中的尾元素\n\n   blpop(key1, key2,… key N, timeout)：lpop命令的block版本。即当timeout为0时，若遇到名称为key i的list不存在或该list为空，则命令结束。如果timeout>0，则遇到上述情况时，等待timeout秒，如果问题没有解决，则对key i+1开始的list执行pop操作。\n\n   brpop(key1, key2,… key N, timeout)：rpop的block版本。参考上一命令。\n\n   rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部\n\n对Set操作的命令\n=========\n   sadd(key, member)：向名称为key的set中添加元素member\n\n   srem(key, member) ：删除名称为key的set中的元素member\n\n   spop(key) ：随机返回并删除名称为key的set中一个元素\n\n   smove(srckey, dstkey, member) ：将member元素从名称为srckey的集合移到名称为dstkey的集合\n\n   scard(key) ：返回名称为key的set的基数\n\n   sismember(key, member) ：测试member是否是名称为key的set的元素\n\n   sinter(key1, key2,…key N) ：求交集\n\n   sinterstore(dstkey, key1, key2,…key N) ：求交集并将交集保存到dstkey的集合\n\n   sunion(key1, key2,…key N) ：求并集\n\n   sunionstore(dstkey, key1, key2,…key N) ：求并集并将并集保存到dstkey的集合\n\n   sdiff(key1, key2,…key N) ：求差集\n\n   sdiffstore(dstkey, key1, key2,…key N) ：求差集并将差集保存到dstkey的集合\n\n   smembers(key) ：返回名称为key的set的所有元素\n\n   srandmember(key) ：随机返回名称为key的set的一个元素\n\n对zset（sorted set）操作的命令\n========\n   zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。\n\n   zrem(key, member) ：删除名称为key的zset中的元素member\n\n   zincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment\n\n   zrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”\n\n   zrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”\n\n   zrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素\n\n   zrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素\n\n   zrangebyscore(key, min, max)：返回名称为key的zset中score >= min且score <= max的所有元素\n\n   zcard(key)：返回名称为key的zset的基数\n\n   zscore(key, element)：返回名称为key的zset中元素element的score\n\n   zremrangebyrank(key, min, max)：删除名称为key的zset中rank >= min且rank <= max的所有元素\n\n   zremrangebyscore(key, min, max) ：删除名称为key的zset中score >= min且score <= max的所有元素\n\n   zunionstore / zinterstore(dstkeyN, key1,…,keyN, WEIGHTS w1,…wN, AGGREGATE SUM|MIN|MAX)：对N个zset求并集和交集，并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。如果没有提供WEIGHT，默认为1。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行SUM运算的值，而MIN和MAX是指，结果集合中元素的score是所有集合对应元素中最小值和最大值。\n\n对Hash操作的命令\n=========\n   hset(key, field, value)：向名称为key的hash中添加元素field<—>value\n\n   hget(key, field)：返回名称为key的hash中field对应的value\n\n   hmget(key, field1, …,field N)：返回名称为key的hash中field i对应的value\n\n   hmset(key, field1, value1,…,field N, value N)：向名称为key的hash中添加元素field i<—>value i\n\n   hincrby(key, field, integer)：将名称为key的hash中field的value增加integer\n\n   hexists(key, field)：名称为key的hash中是否存在键为field的域\n\n   hdel(key, field)：删除名称为key的hash中键为field的域\n\n   hlen(key)：返回名称为key的hash中元素个数\n\n   hkeys(key)：返回名称为key的hash中所有键\n\n   hvals(key)：返回名称为key的hash中所有键对应的value\n\n   hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value\n\n持久化\n========\n   save：将数据同步保存到磁盘\n\n   bgsave：将数据异步保存到磁盘\n\n   lastsave：返回上次成功将数据保存到磁盘的Unix时戳\n\n   shundown：将数据同步保存到磁盘，然后关闭服务\n\n远程服务控制\n=========\n   info：提供服务器的信息和统计\n\n   monitor：实时转储收到的请求\n\n   slaveof：改变复制策略设置\n\n   config：在运行时配置Redis服务器","slug":"Redis的操作方法","updated":1416925446000,"excerpt":"","_id":"bpldp3guq4p74ura","comments":true,"layout":"post","photos":[],"link":""},{"title":"js中获取时间戳的方法","date":1417444704000,"categories":["tpesbjcpw3rq03xi"],"tags":["gscgstr6rs8o2myy"],"content":"<p>最近用时间对象特别多，所以取时间戳就成了经常需要用到的方法了</p>\n<p>这里给列出几种我目前知道的关于获取时间戳的方法，应该是不全的</p>\n<h1 id=\"一，getTime()\">一，getTime()</h1>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"keyword\">var</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime()</div></pre></figure>\n\n<p>这个可能是被最多人所熟知的方法了，用时间对象的的<code>getTime</code>方法，直接获取时间戳</p>\n<h1 id=\"二，时间对象的隐式类型转换\">二，时间对象的隐式类型转换</h1>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"keyword\">var</span> oDate = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</div><div class=\"line\"><span class=\"keyword\">var</span> time1 = +oDate</div><div class=\"line\"><span class=\"keyword\">var</span> time2 = oDate * <span class=\"number\">1</span></div></pre></figure>\n\n<p>由于javascript属于弱类型语言，所以在计算时间对象的时候，js会默认把时间对象转化成数字时间戳</p>\n<h1 id=\"三，Date-now()\">三，Date.now()</h1>\n<figure class=\"highlight\"><pre><div class=\"line\">var <span class=\"built_in\">time</span> = <span class=\"built_in\">Date</span>.<span class=\"built_in\">now</span>()</div></pre></figure>\n\n<p>时间对象提供的方法，获取当前的时间戳，不需要先去<code>new</code>一个对象</p>\n<h1 id=\"四，Date-parse()\">四，Date.parse()</h1>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"keyword\">var</span> time = <span class=\"built_in\">Date</span>.parse(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())</div></pre></figure>\n\n<p>用时间对象提供的解析方法来解析新生成的时间对象【(╯‵□′)╯︵┻━┻多此一举啊混蛋</p>\n<h1 id=\"五，valueOf()\">五，valueOf()</h1>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"keyword\">var</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().valueOf()</div></pre></figure>\n\n<p>用valueOf来获取时间对象的值，返回的是时间戳</p>\n","source":"_posts/js中获取时间戳的方法.md","raw":"title: js中获取时间戳的方法\ndate: 2014-12-01 22:38:24\ncategories: 技术\ntags: js\n---\n最近用时间对象特别多，所以取时间戳就成了经常需要用到的方法了\n\n这里给列出几种我目前知道的关于获取时间戳的方法，应该是不全的\n\n一，getTime()\n============\n\n```\nvar time = new Date().getTime()\n```\n\n这个可能是被最多人所熟知的方法了，用时间对象的的`getTime`方法，直接获取时间戳\n\n二，时间对象的隐式类型转换\n=============\n\n```\nvar oDate = new Date()\nvar time1 = +oDate\nvar time2 = oDate * 1\n```\n\n由于javascript属于弱类型语言，所以在计算时间对象的时候，js会默认把时间对象转化成数字时间戳\n\n三，Date.now()\n==============\n\n```\nvar time = Date.now()\n```\n\n时间对象提供的方法，获取当前的时间戳，不需要先去`new`一个对象\n\n四，Date.parse()\n=====\n\n```\nvar time = Date.parse(new Date())\n```\n\n用时间对象提供的解析方法来解析新生成的时间对象【(╯‵□′)╯︵┻━┻多此一举啊混蛋\n\n五，valueOf()\n====\n\n```\nvar time = new Date().valueOf()\n```\n\n用valueOf来获取时间对象的值，返回的是时间戳","slug":"js中获取时间戳的方法","updated":1417490180000,"excerpt":"","_id":"m17k6eq0hg0mjgim","comments":true,"layout":"post","photos":[],"link":""},{"title":"npm网速慢的解决办法","date":1411917751000,"categories":["tpesbjcpw3rq03xi"],"tags":["oypeex4xmny41osd","wdwsejiu177doh12"],"content":"<p>国内经常会遇到npm特别慢的情况，可以通过下面的方式，更改npm的镜像</p>\n<h3 id=\"通过下面命令设置镜像\">通过下面命令设置镜像</h3>\n<p><code>npm config set registry http://r.cnpmjs.org</code></p>\n<p>国内镜像：</p>\n<blockquote>\n<p><a href=\"http://r.cnpmjs.org\" target=\"_blank\" rel=\"external\">http://r.cnpmjs.org</a><br><a href=\"http://registry.cnpmjs.org\" target=\"_blank\" rel=\"external\">http://registry.cnpmjs.org</a><br><a href=\"http://registry.npm.taobao.org\" target=\"_blank\" rel=\"external\">http://registry.npm.taobao.org</a></p>\n</blockquote>\n<p>官方镜像：</p>\n<blockquote>\n<p><a href=\"https://registry.npmjs.org\" target=\"_blank\" rel=\"external\">https://registry.npmjs.org</a></p>\n</blockquote>\n<h3 id=\"常用的npm的命令\">常用的npm的命令</h3>\n<p><code>npm install -g</code>全局安装包<br><code>npm ls -g</code>   查看全局已安装的包<br><code>npm install &lt;package&gt;@&lt;version&gt;</code>安装指定版本的包</p>\n<h3 id=\"附上常用的库的地址\">附上常用的库的地址</h3>\n<p>JQuery地址</p>\n<blockquote>\n<p><a href=\"http://code.jquery.com/jquery-1.11.0.min.js\" target=\"_blank\" rel=\"external\">http://code.jquery.com/jquery-1.11.0.min.js</a></p>\n</blockquote>\n<p>bootstrapev2地址</p>\n<blockquote>\n<p><a href=\"http://cdn.bootcss.com/twitter-bootstrap/2.3.2/css/bootstrap.min.css\" target=\"_blank\" rel=\"external\">http://cdn.bootcss.com/twitter-bootstrap/2.3.2/css/bootstrap.min.css</a><br><a href=\"http://cdn.bootcss.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js\" target=\"_blank\" rel=\"external\">http://cdn.bootcss.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js</a></p>\n</blockquote>\n","source":"_posts/npm网速慢的解决办法.md","raw":"title: npm网速慢的解决办法\ndate: 2014-09-28 23:22:31\ncategories: 技术\ntags: [npm, nodejs]\n---\n\n国内经常会遇到npm特别慢的情况，可以通过下面的方式，更改npm的镜像\n\n###通过下面命令设置镜像\n``npm config set registry http://r.cnpmjs.org``\n\n国内镜像：\n>http://r.cnpmjs.org\n>http://registry.cnpmjs.org \n>http://registry.npm.taobao.org\n\n官方镜像：\n>https://registry.npmjs.org\n\n###常用的npm的命令\n``npm install -g``全局安装包\n``npm ls -g``   查看全局已安装的包\n``npm install <package>@<version>``安装指定版本的包\n\n\n###附上常用的库的地址\n\nJQuery地址\n>http://code.jquery.com/jquery-1.11.0.min.js\n\nbootstrapev2地址\n>http://cdn.bootcss.com/twitter-bootstrap/2.3.2/css/bootstrap.min.css\n>http://cdn.bootcss.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js\n\n\n","slug":"npm网速慢的解决办法","updated":1411958621000,"excerpt":"","_id":"w7nq8dq23qy97nji","comments":true,"layout":"post","photos":[],"link":""},{"title":"关于在Meteor中写自定义登录需要注意的地方","date":1413209946000,"categories":["tpesbjcpw3rq03xi"],"tags":["i2s34gm2iixl2i7j"],"content":"<p>上一篇博文翻译了Meteorhack的一篇关于如何编写自定义登录方式之后，对<code>Meteor</code>的’Accounts’模块有了一定的认识，为在实际工作中提供了理论知识</p>\n<p>通过这几天在编写自定义登录模块的摸爬滚打之后，也逐渐开始遇到了一些问题</p>\n<h1 id=\"问题一———-第三方登录和原有登录系统冲突\">问题一———-第三方登录和原有登录系统冲突</h1>\n<p>我在编写登录模块的时候，由于系统本身已经添加了<code>accounts-password</code>包，在编写我自己的<code>registerLoginHandler</code>之后，会优先去执行<code>accounts-password</code>包里面的函数，导致每次我调用登录模块，换来的都是<code>Match failed</code>的错误</p>\n<p>我通过查看<code>accounts-password</code>包的<a href=\"https://github.com/meteor/meteor/blob/devel/packages%2Faccounts-password%2Fpassword_server.js#L140\" target=\"_blank\" rel=\"external\">源码</a>之后，我发现，<code>accounts-password</code>的登录逻辑里，会判断传入的<code>loginRequest</code>中是否含有<code>password</code>和<code>srp</code>，在0.8.1之前你只能用密码登录，所以提供了一种登录方法，在0.8.1之后，你还可以使用<code>srp</code>来登录，所以<code>Meteor</code>又写了另外一种登录方法</p>\n<p>通过查看发现，是否调用<code>accounts-password</code>的关键在于，你是否传递了<code>password</code>和<code>srp</code>，通过改进后，我把<code>loginRequest</code>传入的key从<code>password</code>更改成了<code>ldap_password</code>，更改之后，就能绕过<code>accounts-password</code>包的登录机制了</p>\n<h1 id=\"问题二————-关于调用Accounts-callLoginMethod方法中的methodName\">问题二————-关于调用Accounts.callLoginMethod方法中的methodName</h1>\n<p>这个问题一直困扰我，我在<code>registerLoginHandler</code>的时候，给我的method声明了名称，但是在实际调用中，我给<code>Accounts.callLoginMethod</code>传递了<code>methodName</code>却提示我<code>method not found</code>的错误，这问题有待解决</p>\n<p>先只写这么多，等我第三方登录模块写完之后，应该会写一个介绍<code>ldapjs</code>的博文</p>\n","source":"_posts/关于在Meteor中写自定义登录需要注意的地方.md","raw":"title: 关于在Meteor中写自定义登录需要注意的地方\ndate: 2014-10-13 22:19:06\ncategories: 技术\ntags: Meteor\n---\n\n上一篇博文翻译了Meteorhack的一篇关于如何编写自定义登录方式之后，对`Meteor`的'Accounts'模块有了一定的认识，为在实际工作中提供了理论知识\n\n通过这几天在编写自定义登录模块的摸爬滚打之后，也逐渐开始遇到了一些问题\n\n问题一-------第三方登录和原有登录系统冲突\n==========================\n我在编写登录模块的时候，由于系统本身已经添加了`accounts-password`包，在编写我自己的`registerLoginHandler`之后，会优先去执行`accounts-password`包里面的函数，导致每次我调用登录模块，换来的都是`Match failed`的错误\n\n我通过查看`accounts-password`包的[源码](https://github.com/meteor/meteor/blob/devel/packages%2Faccounts-password%2Fpassword_server.js#L140)之后，我发现，`accounts-password`的登录逻辑里，会判断传入的`loginRequest`中是否含有`password`和`srp`，在0.8.1之前你只能用密码登录，所以提供了一种登录方法，在0.8.1之后，你还可以使用`srp`来登录，所以`Meteor`又写了另外一种登录方法\n\n通过查看发现，是否调用`accounts-password`的关键在于，你是否传递了`password`和`srp`，通过改进后，我把`loginRequest`传入的key从`password`更改成了`ldap_password`，更改之后，就能绕过`accounts-password`包的登录机制了\n\n问题二---------关于调用Accounts.callLoginMethod方法中的methodName\n=======================\n这个问题一直困扰我，我在`registerLoginHandler`的时候，给我的method声明了名称，但是在实际调用中，我给`Accounts.callLoginMethod`传递了`methodName`却提示我`method not found`的错误，这问题有待解决\n\n\n\n先只写这么多，等我第三方登录模块写完之后，应该会写一个介绍`ldapjs`的博文","slug":"关于在Meteor中写自定义登录需要注意的地方","updated":1413213673000,"excerpt":"","_id":"5zrq8i6lwcqnl7at","comments":true,"layout":"post","photos":[],"link":""},{"title":"在Meteor的Template.helper中需要注意的坑","date":1417490157000,"categories":["tpesbjcpw3rq03xi"],"tags":["i2s34gm2iixl2i7j"],"content":"<h1 id=\"问题详情\">问题详情</h1>\n<p>在<code>Meteor</code>中，由于某些特性，会使<code>{{foo bar}}</code>配合<code>registerHelper</code>变得很便捷，用起来很舒服</p>\n<p>但是这东西会有些小坑，这些小坑是API中未曾提到的（可能是我没看到）</p>\n<p>从<code>Meteor 0.6</code>起，<code>registerHelper</code>这个方法已经换了好几个绑定的对象了，从最开始的<code>Handerbars.registerHelper</code>到<code>UI.registerHelper</code>再到<code>Blaze.registerHelper</code>最后到现在的<code>Template.registerHelper</code>，整个人都凌乱了好吗！</p>\n<p><code>registerHelper</code>的用法是<code>Template.registerHelper(name, function)</code>，<code>function</code>中传递的参数就是调用时<code>{{ foo bar}}</code>传递的参数，我在开发的时候遇到过这种问题，当我将<code>{{foo bar}}</code>中传递进来的参数取名叫<code>kind</code>的时候，即<code>{{foo kind}}</code>，就会发生意想不到的事情</p>\n<p>定义：</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Template.registerHelper(<span class=\"string\">'foo'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(bar)</span> </span>{</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(bar)</div><div class=\"line\">})</div></pre></figure>\n\n<p>调用：</p>\n<figure class=\"highlight html\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">template</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"index\"</span>&gt;</span></div><div class=\"line\">\t{{#with obj}}</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>{{foo kind}}<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></div><div class=\"line\">\t{{/with}}</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">template</span>&gt;</span></div></pre></figure>\n\n\n\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Template.index.obj = {</div><div class=\"line\">\tkind: <span class=\"string\">'bar'</span></div><div class=\"line\">}</div></pre></figure>\n\n<p>结果<code>bar</code>打印出来的结果不是<code>&#39;bar&#39;</code>，而是<code>&#39;Template_index&#39;</code>，也就是说，当<code>{{foo kind}}</code>的形参起名叫<code>&#39;kind&#39;</code>的时候，实参传递到这个形参上的值，不是实参的值，而是<code>&#39;Template_&#39; + 模板的名字</code></p>\n<h1 id=\"解决办法\">解决办法</h1>\n<p>把<code>kind</code>换成其他名字(❁´▽`❁)</p>\n","source":"_posts/在Meteor的registerHelper中需要注意的坑.md","raw":"title: 在Meteor的Template.helper中需要注意的坑\ndate: 2014-12-02 11:15:57\ncategories: 技术\ntags: Meteor\n---\n问题详情\n======\n在`Meteor`中，由于某些特性，会使`{% raw %}{{foo bar}}{% endraw /%}`配合`registerHelper`变得很便捷，用起来很舒服\n\n但是这东西会有些小坑，这些小坑是API中未曾提到的（可能是我没看到）\n\n从`Meteor 0.6`起，`registerHelper`这个方法已经换了好几个绑定的对象了，从最开始的`Handerbars.registerHelper`到`UI.registerHelper`再到`Blaze.registerHelper`最后到现在的`Template.registerHelper`，整个人都凌乱了好吗！\n\n`registerHelper`的用法是`Template.registerHelper(name, function)`，`function`中传递的参数就是调用时`{% raw %}{{ foo bar}}{% endraw /%}`传递的参数，我在开发的时候遇到过这种问题，当我将`{% raw %}{{foo bar}}{% endraw /%}`中传递进来的参数取名叫`kind`的时候，即`{% raw %}{{foo kind}}{% endraw /%}`，就会发生意想不到的事情\n\n定义：\n```javascript\nTemplate.registerHelper('foo', function(bar) {\n\tconsole.log(bar)\n})\n```\n\n调用：\n\n```html\n<template name=\"index\">\n\t{% raw %}{{#with obj}}{% endraw %}\n\t\t<p>{% raw %}{{foo kind}}{% endraw %}</p>\n\t{% raw %}{{/with}}{% endraw %}\n</template>\n```\n```javascript\nTemplate.index.obj = {\n\tkind: 'bar'\n}\n```\n结果`bar`打印出来的结果不是`'bar'`，而是`'Template_index'`，也就是说，当`{% raw %}{{foo kind}}{% endraw %}`的形参起名叫`'kind'`的时候，实参传递到这个形参上的值，不是实参的值，而是`'Template_' + 模板的名字`\n\n解决办法\n=====\n把`kind`换成其他名字(❁´▽`❁)","slug":"在Meteor的registerHelper中需要注意的坑","updated":1417492423000,"excerpt":"","_id":"eftm7vi9m5gz3zh9","comments":true,"layout":"post","photos":[],"link":""},{"title":"简单解析formidable's API","date":1413432065000,"categories":["tpesbjcpw3rq03xi"],"tags":["wdwsejiu177doh12"],"content":"<p>本文翻译自<code>github</code>上的<a href=\"https://github.com/felixge/node-formidable#events\" target=\"_blank\" rel=\"external\">Formidable的官方页面</a></p>\n<h1 id=\"介绍\">介绍</h1>\n<p>一个用来解析数据，特别是上传数据的nodejs模块</p>\n<h1 id=\"安装\">安装</h1>\n<p>这是一个底层的包，如果你使用的是一个高级的类似<code>Express</code>的框架，你可以通过阅读<a href=\"http://stackoverflow.com/questions/11295554/how-to-disable-express-bodyparser-for-file-uploads-node-js\" target=\"_blank\" rel=\"external\">这里</a>来了解如何在<code>Express</code>来使用<code>Formidable</code>。</p>\n<p>你可以使用<code>npm</code>来安装:</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"built_in\">npm</span> install formidable<span class=\"property\">@latest</span></div></pre></figure>\n\n<p>或者手动安装：</p>\n<figure class=\"highlight\"><pre><div class=\"line\">git clone gi<span class=\"variable\">t:</span>//github.<span class=\"keyword\">com</span>/felixge/node-formidable.git formidable</div><div class=\"line\"><span class=\"keyword\">vim</span> my.js</div><div class=\"line\"># var formidable = require(<span class=\"string\">'./formidable'</span>);</div></pre></figure>\n\n<p>注意：Formidable应用了<a href=\"http://github.com/felixge/node-gently\" target=\"_blank\" rel=\"external\">gently</a>来运行单元测试，但是你没必要使用它</p>\n<h1 id=\"例子\">例子</h1>\n<p>解析一个文件上传</p>\n<figure class=\"highlight\"><pre><div class=\"line\">var formidable = require(<span class=\"string\">'formidable'</span>),</div><div class=\"line\">    http = require(<span class=\"string\">'http'</span>),</div><div class=\"line\">    util = require(<span class=\"string\">'util'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"transposed_variable\">http.</span>createServer(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(req, res)</span> {</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"transposed_variable\">req.</span>url == <span class=\"string\">'/upload'</span> && <span class=\"transposed_variable\">req.</span><span class=\"transposed_variable\">method.</span>toLowerCase() == <span class=\"string\">'post'</span>) {</div><div class=\"line\">    <span class=\"comment\">// 解析文件上传</span></div><div class=\"line\">    var form = new <span class=\"transposed_variable\">formidable.</span>IncomingForm();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"transposed_variable\">form.</span>parse(req, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(err, fields, files)</span> {</span></div><div class=\"line\">      <span class=\"transposed_variable\">res.</span>writeHead(<span class=\"number\">200</span>, {<span class=\"string\">'content-type'</span>: <span class=\"string\">'text/plain'</span>});</div><div class=\"line\">      <span class=\"transposed_variable\">res.</span>write(<span class=\"string\">'received upload:\\n\\n'</span>);</div><div class=\"line\">      <span class=\"transposed_variable\">res.</span><span class=\"keyword\">end</span>(<span class=\"transposed_variable\">util.</span>inspect({fields: fields, files: files}));</div><div class=\"line\">    });</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  }</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 展示一个文件上传表单</span></div><div class=\"line\">  <span class=\"transposed_variable\">res.</span>writeHead(<span class=\"number\">200</span>, {<span class=\"string\">'content-type'</span>: <span class=\"string\">'text/html'</span>});</div><div class=\"line\">  <span class=\"transposed_variable\">res.</span><span class=\"keyword\">end</span>(</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"</span>/upload<span class=\"string\">\" enctype=\"</span>multipart/form-data<span class=\"string\">\" method=\"</span>post<span class=\"string\">\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"</span>text<span class=\"string\">\" name=\"</span>title<span class=\"string\">\"&gt;&lt;br&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"</span>file<span class=\"string\">\" name=\"</span>upload<span class=\"string\">\" multiple=\"</span>multiple<span class=\"string\">\"&gt;&lt;br&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"</span>submit<span class=\"string\">\" value=\"</span>Upload<span class=\"string\">\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span></div><div class=\"line\">  );</div><div class=\"line\">}).listen(<span class=\"number\">8080</span>);</div></pre></figure>\n\n<h1 id=\"API\">API</h1>\n<h3 id=\"Formidable-IncomingForm\">Formidable.IncomingForm</h3>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"keyword\">var</span> form = <span class=\"keyword\">new</span> formidable.IncomingForm()</div></pre></figure>\n\n<p>新建一个传入表单的对象</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.encoding = <span class=\"string\">'utf-8'</span></div></pre></figure>\n\n<p>设置上传表单域的编码</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.uploadDir = <span class=\"string\">'/my/dir'</span></div></pre></figure>\n\n<p>设置文件上传的目录，稍后你可以使用<code>fs.rename()</code>来更改它。默认值为<code>os.tmpDir()</code>。</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"variable\">keepExtensions =</span> <span class=\"constant\">false</span></div></pre></figure>\n\n<p>如果你想上传的文件保留扩展名，把这一项设置为<code>true</code></p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"title\">form</span>.<span class=\"typedef\"><span class=\"keyword\">type</span></span></div></pre></figure>\n\n<p>根据请求来判断的编码类型</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.maxFieldsSize = 2 <span class=\"keyword\">*</span> 1024 <span class=\"keyword\">*</span> 1024</div></pre></figure>\n\n<p>限制分配给处理域的内存大小，如果分配的值超过这个数值，则<code>error</code>时间将会被触发，默认值为2MB。</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"attribute\">form.maxFields </span>=<span class=\"string\"> 1000</span></div></pre></figure>\n\n<p>限制域中解码查询语句的个数。默认值为1000</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"variable\">hash =</span> <span class=\"constant\">false</span></div></pre></figure>\n\n<p>如果你想对传入的文件进行校验，请设置该属性为<code>sha1</code>或者<code>md5</code></p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"variable\">multiples =</span> <span class=\"constant\">false</span></div></pre></figure>\n\n<p>开启这个选项后，你就能使用HTML5的多文件上传功能了，调用<code>form.parse</code>时传入的就是一个文件的数组</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.bytesReceived</div></pre></figure>\n\n<p>从表单获取到的字节数</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.bytesExpected</div></pre></figure>\n\n<p>预计还剩的字节数</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.parse(request, [<span class=\"keyword\">cb</span>])</div></pre></figure>\n\n<p>从一个node.js上传请求数据中解析内容。如果有<code>cb</code>传入，所有的文件和请求将会传递到这个callback,例如:</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.parse(req, <span class=\"keyword\">function</span>(err, fields, files) {</div><div class=\"line\">\t// <span class=\"keyword\">...</span></div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\">form.onPart(part);</div></pre></figure>\n\n<p>如果你想直接访问<code>multipart stream</code>，你可以覆盖掉这个方法。但是这么做之后会禁用掉<code>field</code>/<code>file</code>事件处理。</p>\n<p>如果你想用Formidable来处理某些文件，你可以这么做：</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.onPart = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(part)</span> </span>{</div><div class=\"line\">  <span class=\"keyword\">if</span> (!part.filename) {</div><div class=\"line\">    <span class=\"comment\">// let formidable handle all non-file parts</span></div><div class=\"line\">    form.handlePart(part);</div><div class=\"line\">  }</div><div class=\"line\">}</div></pre></figure>\n\n<h3 id=\"Formidable-File\">Formidable.File</h3>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"keyword\">file</span>.<span class=\"keyword\">size</span> = <span class=\"number\">0</span></div></pre></figure>\n\n<p>上传文件的大小，单位是bytes，如果文件还在上传中（如在<code>fileBegin</code>事件中）,这个数值将会告诉你有多少字节被写入了硬盘</p>\n<figure class=\"highlight\"><pre><div class=\"line\">file.<span class=\"variable\">path =</span> <span class=\"constant\">null</span></div></pre></figure>\n\n<p>当前文件的被写入的路径。如果你不想把你的文件放入设置的公共路径，你可以在<code>fileBegin</code>事件中更改这个值</p>\n<figure class=\"highlight\"><pre><div class=\"line\">file.<span class=\"variable\">name =</span> <span class=\"constant\">null</span></div></pre></figure>\n\n<p>根据客户端获取到的文件上传后的名字</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"keyword\">file</span>.<span class=\"keyword\">type</span> = <span class=\"keyword\">null</span></div></pre></figure>\n\n<p>根据客户端获取到的文件上传后的<code>mine</code>类型</p>\n<figure class=\"highlight\"><pre><div class=\"line\">file.<span class=\"variable\">lastModifiedDate =</span> <span class=\"constant\">null</span></div></pre></figure>\n\n<p>文件最后被更改的时间对象</p>\n<figure class=\"highlight\"><pre><div class=\"line\">file.<span class=\"variable\">hash =</span> <span class=\"constant\">null</span></div></pre></figure>\n\n<p>得到经过hash计算后的十六进制值</p>\n<h4 id=\"Formidable-File#toJSON()\">Formidable.File#toJSON()</h4>\n<p>这个方法返回一个表示文件的JSON数据，可以使用<code>JSON.stringify()</code>来使用它去记录日志或者响应请求</p>\n<h1 id=\"事件\">事件</h1>\n<h4 id=\"‘progress’\">‘progress’</h4>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'progress'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(bytesReceived, bytesExpected)</span> <span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<p>发生在每一个数据传入的块被解析之后，可以用来实现进度条</p>\n<h4 id=\"‘field’\">‘field’</h4>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'field'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(name, value)</span> <span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<h4 id=\"‘fileBegin’\">‘fileBegin’</h4>\n<p>每当一个域或者键值对被接受到的时候</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'fileBegin'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(name, <span class=\"keyword\">file</span>)</span> <span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<h4 id=\"‘file’\">‘file’</h4>\n<p>当一个新的文件在上传流中被检测到的时候触发。 Use this even if you want to stream the file to somewhere else while buffering the upload on the file system.(没理解T_T)</p>\n<p>每当一个文件被接收的时候触发，<code>file</code>是<code>File</code>的实例</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'file'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(name, <span class=\"keyword\">file</span>)</span> <span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<h4 id=\"‘error’\">‘error’</h4>\n<p>当有表单处理错误的时候触发，请求会自动暂停，如果你需要继续触发<code>data</code>事件，你需要手动调用<code>request.resume()</code></p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(err)</span> <span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<h4 id=\"‘aborted’\">‘aborted’</h4>\n<p>当用户使请求终止的时候触发，现在这个事件是由<code>socket</code>的<code>close</code>和<code>timeout</code>共同触发的，将来会把<code>timeout</code>给独立出来(这需要更改node的核心)。</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'aborted'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span><span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<h4 id=\"‘end’\">‘end’</h4>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'end'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<p>当整个请求被接收完并写入磁盘后触发。这里就是你返回数据的一个好地方。</p>\n<h1 id=\"译者注\">译者注</h1>\n<p>小白前端一枚，对该模块不了解的情况下翻译，本意是为了辅助自己更好的理解该模块，如有错误，请指出，谢谢。</p>\n","source":"_posts/简单解析formidable-s-API.md","raw":"title: 简单解析formidable's API\ndate: 2014-10-16 12:01:05\ncategories: 技术\ntags: nodejs\n---\n\n本文翻译自`github`上的[Formidable的官方页面](https://github.com/felixge/node-formidable#events)\n\n介绍\n=================\n一个用来解析数据，特别是上传数据的nodejs模块\n\n安装\n=========\n这是一个底层的包，如果你使用的是一个高级的类似`Express`的框架，你可以通过阅读[这里](http://stackoverflow.com/questions/11295554/how-to-disable-express-bodyparser-for-file-uploads-node-js)来了解如何在`Express`来使用`Formidable`。\n\n你可以使用`npm`来安装:\n```\nnpm install formidable@latest\n```\n\n或者手动安装：\n```\ngit clone git://github.com/felixge/node-formidable.git formidable\nvim my.js\n# var formidable = require('./formidable');\n```\n\n注意：Formidable应用了[gently](http://github.com/felixge/node-gently)来运行单元测试，但是你没必要使用它\n\n例子\n===========\n解析一个文件上传\n```\nvar formidable = require('formidable'),\n    http = require('http'),\n    util = require('util');\n\nhttp.createServer(function(req, res) {\n  if (req.url == '/upload' && req.method.toLowerCase() == 'post') {\n    // 解析文件上传\n    var form = new formidable.IncomingForm();\n\n    form.parse(req, function(err, fields, files) {\n      res.writeHead(200, {'content-type': 'text/plain'});\n      res.write('received upload:\\n\\n');\n      res.end(util.inspect({fields: fields, files: files}));\n    });\n\n    return;\n  }\n\n  // 展示一个文件上传表单\n  res.writeHead(200, {'content-type': 'text/html'});\n  res.end(\n    '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n    '<input type=\"text\" name=\"title\"><br>'+\n    '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n    '<input type=\"submit\" value=\"Upload\">'+\n    '</form>'\n  );\n}).listen(8080);\n```\n\nAPI\n==============\n### Formidable.IncomingForm\n\n```\nvar form = new formidable.IncomingForm()\n```\n新建一个传入表单的对象\n\n```\nform.encoding = 'utf-8'\n```\n设置上传表单域的编码\n\n```\nform.uploadDir = '/my/dir'\n```\n设置文件上传的目录，稍后你可以使用`fs.rename()`来更改它。默认值为`os.tmpDir()`。\n\n```\nform.keepExtensions = false\n```\n如果你想上传的文件保留扩展名，把这一项设置为`true`\n\n```\nform.type\n```\n根据请求来判断的编码类型\n\n```\nform.maxFieldsSize = 2 * 1024 * 1024\n```\n限制分配给处理域的内存大小，如果分配的值超过这个数值，则`error`时间将会被触发，默认值为2MB。\n\n```\nform.maxFields = 1000\n```\n限制域中解码查询语句的个数。默认值为1000\n\n```\nform.hash = false\n```\n如果你想对传入的文件进行校验，请设置该属性为`sha1`或者`md5`\n\n```\nform.multiples = false\n```\n开启这个选项后，你就能使用HTML5的多文件上传功能了，调用`form.parse`时传入的就是一个文件的数组\n\n```\nform.bytesReceived\n```\n从表单获取到的字节数\n\n```\nform.bytesExpected\n```\n预计还剩的字节数\n\n```\nform.parse(request, [cb])\n```\n从一个node.js上传请求数据中解析内容。如果有`cb`传入，所有的文件和请求将会传递到这个callback,例如:\n```\nform.parse(req, function(err, fields, files) {\n\t// ...\n});\n\nform.onPart(part);\n```\n如果你想直接访问`multipart stream`，你可以覆盖掉这个方法。但是这么做之后会禁用掉`field`/`file`事件处理。\n\n如果你想用Formidable来处理某些文件，你可以这么做：\n```\nform.onPart = function(part) {\n  if (!part.filename) {\n    // let formidable handle all non-file parts\n    form.handlePart(part);\n  }\n}\n```\n\n###Formidable.File\n```\nfile.size = 0\n```\n上传文件的大小，单位是bytes，如果文件还在上传中（如在`fileBegin`事件中）,这个数值将会告诉你有多少字节被写入了硬盘\n\n```\nfile.path = null\n```\n当前文件的被写入的路径。如果你不想把你的文件放入设置的公共路径，你可以在`fileBegin`事件中更改这个值\n\n```\nfile.name = null\n```\n根据客户端获取到的文件上传后的名字\n\n```\nfile.type = null\n```\n根据客户端获取到的文件上传后的`mine`类型\n```\nfile.lastModifiedDate = null\n```\n文件最后被更改的时间对象\n\n```\nfile.hash = null\n```\n得到经过hash计算后的十六进制值\n\n####Formidable.File#toJSON()\n这个方法返回一个表示文件的JSON数据，可以使用`JSON.stringify()`来使用它去记录日志或者响应请求\n\n事件\n===========\n####'progress'\n```\nform.on('progress', function(bytesReceived, bytesExpected) {\n});\n```\n发生在每一个数据传入的块被解析之后，可以用来实现进度条\n####'field'\n```\nform.on('field', function(name, value) {\n});\n```\n####'fileBegin'\n每当一个域或者键值对被接受到的时候\n```\nform.on('fileBegin', function(name, file) {\n});\n```\n\n####'file'\n当一个新的文件在上传流中被检测到的时候触发。 Use this even if you want to stream the file to somewhere else while buffering the upload on the file system.(没理解T_T)\n\n每当一个文件被接收的时候触发，`file`是`File`的实例\n```\nform.on('file', function(name, file) {\n});\n```\n####'error'\n当有表单处理错误的时候触发，请求会自动暂停，如果你需要继续触发`data`事件，你需要手动调用`request.resume()`\n```\nform.on('error', function(err) {\n});\n```\n####'aborted'\n当用户使请求终止的时候触发，现在这个事件是由`socket`的`close`和`timeout`共同触发的，将来会把`timeout`给独立出来(这需要更改node的核心)。\n```\nform.on('aborted', function(){\n});\n```\n####'end'\n```\nform.on('end',function() {\n});\n```\n当整个请求被接收完并写入磁盘后触发。这里就是你返回数据的一个好地方。\n\n译者注\n======\n小白前端一枚，对该模块不了解的情况下翻译，本意是为了辅助自己更好的理解该模块，如有错误，请指出，谢谢。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"简单解析formidable-s-API","updated":1416449476000,"excerpt":"","_id":"owk8suio5ywvn503","comments":true,"layout":"post","photos":[],"link":""},{"title":"学习React Native(Guide部分)","categories":["tpesbjcpw3rq03xi"],"tags":["yyocpt37hxcjo3hq","u8x9cbangom3fd91"],"date":1428505981000,"content":"<p>本文为学习<code>React Native</code>的笔记整理而成，仅做个人备忘使用</p>\n<h1 id=\"样式\">样式</h1>\n<h2 id=\"声明样式\">声明样式</h2>\n<p>在<code>React Native</code>中声明样式的方法如下：</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\"><span class=\"keyword\">var</span> styles = StyleSheet.create({</div><div class=\"line\">  base: {</div><div class=\"line\">    width: <span class=\"number\">38</span>,</div><div class=\"line\">    height: <span class=\"number\">38</span>,</div><div class=\"line\">  },</div><div class=\"line\">  background: {</div><div class=\"line\">    backgroundColor: <span class=\"string\">'#222222'</span>,</div><div class=\"line\">  },</div><div class=\"line\">  active: {</div><div class=\"line\">    borderWidth: <span class=\"number\">2</span>,</div><div class=\"line\">    borderColor: <span class=\"string\">'#00ff00'</span>,</div><div class=\"line\">  },</div><div class=\"line\">});</div></pre></figure>\n\n<p>使用<code>StyleSheet.create</code>来构造样式，传入对象作为参数。要确保值是定值且把模糊的类型转换成明确的数字类型。写完之后要保证每个只定义过一次。</p>\n<h2 id=\"使用样式\">使用样式</h2>\n<p>主要的使用方法即是给style属性赋值</p>\n<figure class=\"highlight html\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">Text</span> <span class=\"attribute\">style</span>=<span class=\"value\">{styles.base}</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">View</span> <span class=\"attribute\">style</span>=<span class=\"value\">{styles.background}</span> /&gt;</span></div></pre></figure>\n\n<p>也可以给style用数组赋值</p>\n<figure class=\"highlight html\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">View</span> <span class=\"attribute\">style</span>=<span class=\"value\">{[styles.base,</span> <span class=\"attribute\">styles.background</span>]} /&gt;</span></div></pre></figure>\n\n<p>你可以在其间做一些判断</p>\n<figure class=\"highlight\"><pre><div class=\"line\">&lt;View style={[style.<span class=\"keyword\">base</span>, <span class=\"keyword\">this</span>.state.active && styles.active]} /&gt;</div></pre></figure>\n\n<p>如果非到不得已的情况，你还可以在style中添加对象，但这特别容易混淆，不建议你这么做</p>\n<figure class=\"highlight\"><pre><div class=\"line\">&lt;View style={[styles.<span class=\"keyword\">base</span>, {</div><div class=\"line\">    width: <span class=\"keyword\">this</span>.state.width,</div><div class=\"line\">    height: <span class=\"keyword\">this</span>.state.width * <span class=\"keyword\">this</span>.state.aspectRatio</div><div class=\"line\">}]} /&gt;</div></pre></figure>\n\n<h2 id=\"传递style\">传递style</h2>\n<p>为了使你指定的样式在你的组件中使用，你需要传递style，使用<code>View.propTypes.style</code>和<code>Text.propTypes.style</code>来传递，注意，你需要确认传递的仅可能是样式</p>\n<figure class=\"highlight\"><pre><div class=\"line\">var List = React.createClass({</div><div class=\"line\">  propTypes: {</div><div class=\"line\">    style: View.propTypes.style,</div><div class=\"line\">    elementStyle: View.propTypes.style,</div><div class=\"line\">  },</div><div class=\"line\">  render: <span class=\"keyword\">function</span>() {</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;View style={this.props.style}&gt;</div><div class=\"line\">        {elements.map((element) =&gt;</div><div class=\"line\">          &lt;View style={[styles.element, this.props.elementStyle]} /&gt;</div><div class=\"line\">        )}</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  }</div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\">// <span class=\"keyword\">...</span> <span class=\"keyword\">in</span> another file <span class=\"keyword\">...</span></div><div class=\"line\">&lt;List style={styles.list} elementStyle={styles.listElement} /&gt;</div></pre></figure>\n\n<h1 id=\"手势响应系统\">手势响应系统</h1>\n<p>在手机上，手势响应比web上要复杂的多。一个触控可能经历好几个阶段才能定义出用于的意图。例如，app需要判定这个操作是在控件上上下滑动还是左右侧滑或是触碰。并且这些操作可能在操作的过程中更改，甚至存在多点触控的情况。</p>\n<p>触摸响应系统使组件去判定这些触摸共同作用，并且不考虑附加的情况，例如父或子组件。<br>这个系统被定义在<code>ResponderEventPlugin.js</code>中。</p>\n<h2 id=\"最佳实践\">最佳实践</h2>\n","source":"_posts/学习React-Native.md","raw":"title: 学习React Native(Guide部分)\ncategories: 技术\ntags:\n  - React Native\n  - iOS\ndate: 2015-04-08 23:13:01\n---\n\n本文为学习`React Native`的笔记整理而成，仅做个人备忘使用\n\n样式\n================\n\n声明样式\n-----------\n\n在`React Native`中声明样式的方法如下：\n\n```javascript\nvar styles = StyleSheet.create({\n  base: {\n    width: 38,\n    height: 38,\n  },\n  background: {\n    backgroundColor: '#222222',\n  },\n  active: {\n    borderWidth: 2,\n    borderColor: '#00ff00',\n  },\n});\n```\n\n使用`StyleSheet.create`来构造样式，传入对象作为参数。要确保值是定值且把模糊的类型转换成明确的数字类型。写完之后要保证每个只定义过一次。\n\n使用样式\n--------------\n\n主要的使用方法即是给style属性赋值\n\n```html\n<Text style={styles.base} />\n<View style={styles.background} />\n```\n\n也可以给style用数组赋值\n```html\n<View style={[styles.base, styles.background]} />\n```\n\n你可以在其间做一些判断\n\n```\n<View style={[style.base, this.state.active && styles.active]} />\n```\n\n如果非到不得已的情况，你还可以在style中添加对象，但这特别容易混淆，不建议你这么做\n\n```\n<View style={[styles.base, {\n    width: this.state.width,\n    height: this.state.width * this.state.aspectRatio\n}]} />\n```\n\n传递style\n--------------\n\n为了使你指定的样式在你的组件中使用，你需要传递style，使用`View.propTypes.style`和`Text.propTypes.style`来传递，注意，你需要确认传递的仅可能是样式\n\n```\nvar List = React.createClass({\n  propTypes: {\n    style: View.propTypes.style,\n    elementStyle: View.propTypes.style,\n  },\n  render: function() {\n    return (\n      <View style={this.props.style}>\n        {elements.map((element) =>\n          <View style={[styles.element, this.props.elementStyle]} />\n        )}\n      </View>\n    );\n  }\n});\n\n// ... in another file ...\n<List style={styles.list} elementStyle={styles.listElement} />\n```\n\n手势响应系统\n===========\n\n在手机上，手势响应比web上要复杂的多。一个触控可能经历好几个阶段才能定义出用于的意图。例如，app需要判定这个操作是在控件上上下滑动还是左右侧滑或是触碰。并且这些操作可能在操作的过程中更改，甚至存在多点触控的情况。\n\n触摸响应系统使组件去判定这些触摸共同作用，并且不考虑附加的情况，例如父或子组件。\n这个系统被定义在`ResponderEventPlugin.js`中。\n\n最佳实践\n------------","slug":"学习React-Native","updated":1428546408000,"excerpt":"","_id":"z5rdaz2onsnwq5pm","comments":true,"layout":"post","photos":[],"link":""},{"title":"iron-router用法解析","categories":["tpesbjcpw3rq03xi"],"date":1423383249000,"tags":["i2s34gm2iixl2i7j","jfb23b816bd952nh"],"content":"<p>有一段时间没写BLOG了，也有好久没有关注Meteor生态圈了，这次来写一下Meteor中的<code>Iron-router</code>。下面写的例子是为了方便自己记忆的，所以写的不够完善，想了解详细的情况还是得看官方的<a href=\"https://github.com/EventedMind/iron-router/blob/devel/Guide.md\" target=\"_blank\" rel=\"external\">Guide</a></p>\n<p>以下是几个官方例子，我会尽可能的讲明白。。</p>\n<h1 id=\"基本操作\"><a href=\"https://github.com/EventedMind/iron-router/blob/devel/examples%2Fbasic%2Fbasic.js\" target=\"_blank\" rel=\"external\">基本操作</a></h1>\n<p>官方代码:</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Router.route(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>{</div><div class=\"line\">  <span class=\"comment\">// 用{data: {title: 'My Title'}}去渲染Home模板</span></div><div class=\"line\">  <span class=\"keyword\">this</span>.render(<span class=\"string\">'Home'</span>, {data: {title: <span class=\"string\">'My Title'</span>}});</div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 当你访问路由\"/one\"的时候将会自动加载名为one的模板。</span></div><div class=\"line\">Router.route(<span class=\"string\">'/one'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 当你访问路由\"/two\"的时候将会自动加载名为two的模板。</span></div><div class=\"line\">Router.route(<span class=\"string\">'/two'</span>);</div></pre></figure>\n\n<p>上面的例子是<code>Router</code>的基本用法，用<code>Router.route</code>来定义一个路由，这个方法传递两个参数，第一个参数是<em>路径地址</em>，第二个参数是一个匿名函数，主要是配置该路由的。例如以上代码中，<code>this.render(&#39;Home&#39;, {data: {title: &#39;My Title&#39;}});</code>代表的意思是用{data: {title: ‘My Title’}}去渲染Home模板。</p>\n","source":"_posts/iron-router用法解析.md","raw":"title: iron-router用法解析\ncategories: 技术\ndate: 2015-02-08 16:14:09\ntags: [Meteor, 路由]\n---\n\n有一段时间没写BLOG了，也有好久没有关注Meteor生态圈了，这次来写一下Meteor中的`Iron-router`。下面写的例子是为了方便自己记忆的，所以写的不够完善，想了解详细的情况还是得看官方的[Guide](https://github.com/EventedMind/iron-router/blob/devel/Guide.md)\n\n\n以下是几个官方例子，我会尽可能的讲明白。。\n\n[基本操作](https://github.com/EventedMind/iron-router/blob/devel/examples%2Fbasic%2Fbasic.js)\n=======================\n\n官方代码:\n```javascript\nRouter.route('/', function () {\n  // 用{data: {title: 'My Title'}}去渲染Home模板\n  this.render('Home', {data: {title: 'My Title'}});\n});\n\n// 当你访问路由\"/one\"的时候将会自动加载名为one的模板。\nRouter.route('/one');\n\n// 当你访问路由\"/two\"的时候将会自动加载名为two的模板。\nRouter.route('/two');\n```\n\n上面的例子是`Router`的基本用法，用`Router.route`来定义一个路由，这个方法传递两个参数，第一个参数是*路径地址*，第二个参数是一个匿名函数，主要是配置该路由的。例如以上代码中，`this.render('Home', {data: {title: 'My Title'}});`代表的意思是用{data: {title: 'My Title'}}去渲染Home模板。\n\n","slug":"iron-router用法解析","updated":1423470527000,"excerpt":"","_id":"94hkdiuffvygixux","comments":true,"layout":"post","photos":[],"link":""}],"Tag":[{"name":"hybird app","_id":"sl0aau0kcybo43px","posts":["2blnnjbg6o36n36c"]},{"name":"ionic","_id":"5jnnh3psj7laaui1","posts":["2blnnjbg6o36n36c"]},{"name":"nodejs","_id":"wdwsejiu177doh12","posts":["ndg6p32uuc9ed3q6","q75acnxoa2cesbrc","w7nq8dq23qy97nji","owk8suio5ywvn503"]},{"name":"express","_id":"79oh9zi6efbuiccj","posts":["ndg6p32uuc9ed3q6"]},{"name":"Meteor","_id":"i2s34gm2iixl2i7j","posts":["v5ll2yfx48er8kyd","mtchkwlzmdsep8qp","5zrq8i6lwcqnl7at","eftm7vi9m5gz3zh9","94hkdiuffvygixux"]},{"name":"npm","_id":"oypeex4xmny41osd","posts":["q75acnxoa2cesbrc","w7nq8dq23qy97nji"]},{"name":"linux","_id":"8pxwx1ea09hdyd99","posts":["q75acnxoa2cesbrc"]},{"name":"git","_id":"kht1av0nt14rakkn","posts":["5uy8qggc5tdz1nxc"]},{"name":"数据库","_id":"qjgr2r65ycm2eidc","posts":["bpldp3guq4p74ura"]},{"name":"Redis","_id":"xx9i2su2pjsm4s2l","posts":["bpldp3guq4p74ura"]},{"name":"js","_id":"gscgstr6rs8o2myy","posts":["m17k6eq0hg0mjgim"]},{"name":"React Native","_id":"yyocpt37hxcjo3hq","posts":["z5rdaz2onsnwq5pm"]},{"name":"iOS","_id":"u8x9cbangom3fd91","posts":["z5rdaz2onsnwq5pm"]},{"name":"路由","_id":"jfb23b816bd952nh","posts":["94hkdiuffvygixux"]}]}
{"Asset":[{"_id":"themes/kael/source/css/component.css","path":"css/component.css","modified":true},{"_id":"themes/kael/source/css/screen.css","path":"css/screen.css","modified":true},{"_id":"themes/kael/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":true},{"_id":"themes/kael/source/fonts/OpenSans-Bold-webfont.woff","path":"fonts/OpenSans-Bold-webfont.woff","modified":true},{"_id":"themes/kael/source/fonts/OpenSans-Regular-webfont.woff","path":"fonts/OpenSans-Regular-webfont.woff","modified":true},{"_id":"themes/kael/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":true},{"_id":"themes/kael/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":true},{"_id":"themes/kael/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":true},{"_id":"themes/kael/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":true},{"_id":"themes/kael/source/js/jquery.min.js","path":"js/jquery.min.js","modified":true},{"_id":"themes/kael/source/js/lib.js","path":"js/lib.js","modified":true},{"_id":"themes/kael/source/js/main.js","path":"js/main.js","modified":true}],"Cache":[{"_id":"scaffolds/draft.md","mtime":1411976558000},{"_id":"scaffolds/photo.md","mtime":1404891526000},{"_id":"scaffolds/page.md","mtime":1404891526000},{"_id":"scaffolds/post.md","mtime":1411958518000},{"_id":"source/_drafts/Meteor-API-概览一.md","mtime":1416449476000},{"_id":"source/_posts/Extending-Meteor-Accounts.md","mtime":1416449476000},{"_id":"source/_posts/Makefile.md","mtime":1412572984000},{"_id":"source/_posts/Meteor中settings的设置方法.md","mtime":1412836898000},{"_id":"source/_posts/Meteor中由于活性数据造成多次调用的问题.md","mtime":1416449897000},{"_id":"source/_posts/git命令小记.md","mtime":1412572978000},{"_id":"source/_posts/npm网速慢的解决办法.md","mtime":1411958621000},{"_id":"source/_posts/关于在Meteor中写自定义登录需要注意的地方.md","mtime":1413213673000},{"_id":"source/_posts/简单解析formidable-s-API.md","mtime":1416449476000},{"_id":"source/about/index.md","mtime":1411958734000},{"_id":"themes/kael/LICENSE","mtime":1411899186000},{"_id":"themes/kael/README.md","mtime":1411957879000},{"_id":"themes/kael/_config.yml","mtime":1411957864000},{"_id":"themes/kael/layout/archive.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/category.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/index.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/layout.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/page.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/post.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/tag.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/kael/after_all.ejs","mtime":1411899186000},{"_id":"themes/kael/layout/kael/footer.ejs","mtime":1412569711000},{"_id":"themes/kael/layout/kael/head.ejs","mtime":1412571448000},{"_id":"themes/kael/layout/kael/index.ejs","mtime":1416477311000},{"_id":"themes/kael/layout/kael/post.ejs","mtime":1411899186000},{"_id":"themes/kael/source/css/component.css","mtime":1416477317000},{"_id":"themes/kael/source/css/screen.css","mtime":1416477683000},{"_id":"themes/kael/source/fonts/FontAwesome.otf","mtime":1411899186000},{"_id":"themes/kael/source/fonts/OpenSans-Bold-webfont.woff","mtime":1411899186000},{"_id":"themes/kael/source/fonts/OpenSans-Regular-webfont.woff","mtime":1411899186000},{"_id":"themes/kael/source/fonts/fontawesome-webfont.eot","mtime":1411899186000},{"_id":"themes/kael/source/fonts/fontawesome-webfont.svg","mtime":1411899186000},{"_id":"themes/kael/source/fonts/fontawesome-webfont.ttf","mtime":1411899186000},{"_id":"themes/kael/source/fonts/fontawesome-webfont.woff","mtime":1411899186000},{"_id":"themes/kael/source/js/jquery.min.js","mtime":1411899186000},{"_id":"themes/kael/source/js/lib.js","mtime":1411899186000},{"_id":"themes/kael/source/js/main.js","mtime":1416477327000}],"Category":[{"name":"技术","_id":"mord1eecial7zgj6","posts":["eg4swt48jv5ady99","pc0s1dfrll2gc867","phoj0gf8qiornq2s","03wskzpff7rowk0r","f989donotfg9jkp6","169d3b4ms3mnbh19","jwpm3npbj3epzshe"]}],"Page":[{"title":"个人简介","date":1411919729000,"content":"<p>非著名前端工程师幼年体，亚洲善待前端组织（PETE）QQ群主</p>\n","source":"about/index.md","raw":"title: 个人简介\ndate: 2014-09-28 23:55:29\n---\n\n非著名前端工程师幼年体，亚洲善待前端组织（PETE）QQ群主","updated":1411958734000,"path":"about/index.html","excerpt":"","_id":"s6hclta447gz0pj5","comments":true,"layout":"page"}],"Post":[{"title":"扩展Meteor的用户系统","date":1413008069000,"categories":["mord1eecial7zgj6"],"tags":["ija3tw5t2s8zirjw"],"content":"<h1 id=\"简要说明\">简要说明</h1>\n<p>本文是翻译MeteorHacks的一篇关于Meteor中Accounts的文章,原文见<a href=\"https://meteorhacks.com/extending-meteor-accounts.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n<h1 id=\"正文\">正文</h1>\n<p>Meteor有一个非常好的用户认证系统，称之为<a href=\"http://docs.meteor.com/#accounts_api\" target=\"_blank\" rel=\"external\">Accounts</a>。这个认证系统不仅仅为用密码、facebook、twitter和其他平台提供了强大的方法，还因为其与Meteor的核心服务相关联，从而提供高级别的安全。</p>\n<p>好的，但是如果你想添加一个自定义的验证方法呢？Meteor没有给你足够的信息让你这么做。所以我(原作者)开始研究<a href=\"http://goo.gl/PfIvj\" target=\"_blank\" rel=\"external\">Meteor Accounts system</a>的源代码。我发现作者的代码写的十分优雅，同时实现一个自定义的认证方式也非常简单。接下来我们就来说说这个。</p>\n<p>在这个教程里，我将会为我们的Meteor App来创建一个用于管理的自定义认证系统。但这个系统不是一个正式的实现方式，仅仅可以用来演示如何添加自定义认证。</p>\n<h1 id=\"首先，创建一个简单的应用\">首先，创建一个简单的应用</h1>\n<ul>\n<li>用<code>meteor create admin</code>来创建一个Meteor应用</li>\n<li>用<code>meteor add accounts-ui</code>来添加<code>accounts-ui</code>包</li>\n<li>用下面的代码来替换掉<code>admin.html</code>中的代码<br>添加<code>loginButtons</code>来调用<code>accounts-ui</code>包</li>\n</ul>\n<figure class=\"highlight html\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">title</span>&gt;</span>admin<span class=\"tag\">&lt;/<span class=\"title\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">body</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  {{&gt; hello}}</div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">template</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"hello\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">h1</span>&gt;</span>Hello World!<span class=\"tag\">&lt;/<span class=\"title\">h1</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  {{greeting}}</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  {{&gt; loginButtons}}</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"button\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"Click\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">template</span>&gt;</span></div></pre></figure>\n\n<p>现在，当你启动你的应用的时候，你将会看到如下的信息。（不要在意红色的字）<br><img src=\"http://phishingw.qiniudn.com/GNOR8BK.png\" alt=\"初始界面\"></p>\n<h1 id=\"添加登录的处理方式\">添加登录的处理方式</h1>\n<p>现在，我们需要为我们的管理认证系统注册一个登录的方法。下面是一个创建在<code>server/admin.js</code>的服务端函数。</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Accounts.registerLoginHandler(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(loginRequest)</span> </span>{</div><div class=\"line\">  <span class=\"comment\">//Meteor中有多个登录模块 </span></div><div class=\"line\">  <span class=\"comment\">//一个登录的请求需要通过所有的这些登录模块来寻找它所需要的模块</span></div><div class=\"line\">  <span class=\"comment\">//所以，在我们这个登录模块中，我们只需要考虑登录的请求中含有admin字段请求</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(!loginRequest.admin) {</div><div class=\"line\">  \t<span class=\"comment\">//如果不含有admin字段，则return出去</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">  }</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//这里是我们的认证逻辑</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(loginRequest.password != <span class=\"string\">'admin-password'</span>) {</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">  }</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//如果不存在管理帐号，则创建一个，并获取到userId</span></div><div class=\"line\">  <span class=\"keyword\">var</span> userId = <span class=\"literal\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> user = Meteor.users.findOne({username: <span class=\"string\">'admin'</span>});</div><div class=\"line\">  <span class=\"keyword\">if</span>(!user) {</div><div class=\"line\">    userId = Meteor.users.insert({username: <span class=\"string\">'admin'</span>});</div><div class=\"line\">  } <span class=\"keyword\">else</span> {</div><div class=\"line\">    userId = user._id;</div><div class=\"line\">  }</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//发送登录者的userId</span></div><div class=\"line\">  <span class=\"keyword\">return</span> {</div><div class=\"line\">    id: userId</div><div class=\"line\">  }</div><div class=\"line\">});</div></pre></figure>\n\n<p>现在简单的登录函数已经写完了</p>\n<h1 id=\"添加客户端的登录函数\">添加客户端的登录函数</h1>\n<p>新建<code>client/admin.js</code>文件，将以下代码写入其中：</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Meteor.loginAsAdmin = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(password, callback)</span> </span>{</div><div class=\"line\">  <span class=\"comment\">//新建一个带有admin:true的请求，从而让我们的登录模块来处理这个请求</span></div><div class=\"line\">  <span class=\"keyword\">var</span> loginRequest = {admin: <span class=\"literal\">true</span>, password: password};</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//发送登录的请求</span></div><div class=\"line\">  Accounts.callLoginMethod({</div><div class=\"line\">    methodArguments: [loginRequest],</div><div class=\"line\">    userCallback: callback</div><div class=\"line\">  });</div><div class=\"line\">};</div></pre></figure>\n\n<p>现在我们就能添加我们的管理员登录系统。在浏览器的console界面中调用<code>loginAsAdmin</code>方法，然后你会看到你已经登录进去了</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\"><span class=\"comment\">//在浏览器的console中调用</span></div><div class=\"line\">Meteor.loginAsAdmin(<span class=\"string\">'admin-password'</span>);</div></pre></figure>\n\n<p><img src=\"http://phishingw.qiniudn.com/jEa7ZJW.png\" alt=\"登录成功\"></p>\n<h1 id=\"刷新浏览器\">刷新浏览器</h1>\n<p>当你刷新你的浏览器的时候，你会发现你并没有继续处于登录状态。那是因为你没有在登录的时候没有添加一个记录token的功能。<br>用以下的代码来更新<code>server/admin.js</code></p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Accounts.registerLoginHandler(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(loginRequest)</span> </span>{</div><div class=\"line\">  <span class=\"keyword\">if</span>(!loginRequest.admin) {</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">  }</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(loginRequest.password != <span class=\"string\">'admin-password'</span>) {</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">  }</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">var</span> userId = <span class=\"literal\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> user = Meteor.users.findOne({username: <span class=\"string\">'admin'</span>});</div><div class=\"line\">  <span class=\"keyword\">if</span>(!user) {</div><div class=\"line\">    userId = Meteor.users.insert({username: <span class=\"string\">'admin'</span>});</div><div class=\"line\">  } <span class=\"keyword\">else</span> {</div><div class=\"line\">    userId = user._id;</div><div class=\"line\">  }</div><div class=\"line\">  <span class=\"comment\">//以上代码无变化</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//创建一个token并记录在user中</span></div><div class=\"line\">  <span class=\"keyword\">var</span> stampedToken = Accounts._generateStampedLoginToken();</div><div class=\"line\">  <span class=\"comment\">//在Meteor 0.7.x中就已经添加了对hash算法的支持 </span></div><div class=\"line\">  <span class=\"comment\">//在Meteor 0.7.x之前的版本你就不需要做这样的处理</span></div><div class=\"line\">  <span class=\"keyword\">var</span> hashStampedToken = Accounts._hashStampedToken(stampedToken);</div><div class=\"line\">  </div><div class=\"line\">  Meteor.users.update(userId, </div><div class=\"line\">    {$push: {<span class=\"string\">'services.resume.loginTokens'</span>: hashStampedToken}}</div><div class=\"line\">  );</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//把token和userId一并返回</span></div><div class=\"line\">  <span class=\"keyword\">return</span> {</div><div class=\"line\">    id: userId,</div><div class=\"line\">    token: stampedToken.token</div><div class=\"line\">  }</div><div class=\"line\">});</div></pre></figure>\n\n<p>这段代码就能解决刷新后自动退出登录状态的问题了</p>\n<h1 id=\"总结\">总结</h1>\n<p>现在我们来总结一下我们已经做的事情</p>\n<ul>\n<li>我们尝试着为我们的应用做了一个管理登录系统</li>\n<li>为其添加了登录模块</li>\n<li>添加了一个客户端的登录方法</li>\n<li>添加了刷新token</li>\n</ul>\n<p>你可以从Github上来下载<a href=\"https://github.com/arunoda/meteor-custom-authentication-system\" target=\"_blank\" rel=\"external\">源代码</a><br>这样是不是很简单的就能为Meteor应用添加一个新的认证系统货方法了？：）</p>\n","source":"_posts/Extending-Meteor-Accounts.md","raw":"title: 扩展Meteor的用户系统\ndate: 2014-10-11 14:14:29\ncategories: 技术\ntags: Meteor\n---\n\n简要说明\n=======================\n本文是翻译MeteorHacks的一篇关于Meteor中Accounts的文章,原文见[这里](https://meteorhacks.com/extending-meteor-accounts.html)\n\n正文\n======================\nMeteor有一个非常好的用户认证系统，称之为[Accounts](http://docs.meteor.com/#accounts_api)。这个认证系统不仅仅为用密码、facebook、twitter和其他平台提供了强大的方法，还因为其与Meteor的核心服务相关联，从而提供高级别的安全。\n\n好的，但是如果你想添加一个自定义的验证方法呢？Meteor没有给你足够的信息让你这么做。所以我(原作者)开始研究[Meteor Accounts system](http://goo.gl/PfIvj)的源代码。我发现作者的代码写的十分优雅，同时实现一个自定义的认证方式也非常简单。接下来我们就来说说这个。\n\n在这个教程里，我将会为我们的Meteor App来创建一个用于管理的自定义认证系统。但这个系统不是一个正式的实现方式，仅仅可以用来演示如何添加自定义认证。\n\n首先，创建一个简单的应用\n=======================\n* 用`meteor create admin`来创建一个Meteor应用\n* 用`meteor add accounts-ui`来添加`accounts-ui`包\n* 用下面的代码来替换掉`admin.html`中的代码\n添加`loginButtons`来调用`accounts-ui`包\n```html\n<head>\n  <title>admin</title>\n</head>\n<body>\n{% raw %}\n  {{> hello}}\n{% endraw /%}\n</body>\n<template name=\"hello\">\n  <h1>Hello World!</h1>\n{% raw %}\n  {{greeting}}\n{% endraw /%}\n{% raw %}\n  {{> loginButtons}}\n{% endraw /%}\n  <input type=\"button\" value=\"Click\" />\n</template>\n```\n现在，当你启动你的应用的时候，你将会看到如下的信息。（不要在意红色的字）\n![初始界面](http://phishingw.qiniudn.com/GNOR8BK.png)\n\n添加登录的处理方式\n====================\n现在，我们需要为我们的管理认证系统注册一个登录的方法。下面是一个创建在`server/admin.js`的服务端函数。\n```javascript\nAccounts.registerLoginHandler(function(loginRequest) {\n  //Meteor中有多个登录模块 \n  //一个登录的请求需要通过所有的这些登录模块来寻找它所需要的模块\n  //所以，在我们这个登录模块中，我们只需要考虑登录的请求中含有admin字段请求\n  if(!loginRequest.admin) {\n  \t//如果不含有admin字段，则return出去\n    return undefined;\n  }\n\n  //这里是我们的认证逻辑\n  if(loginRequest.password != 'admin-password') {\n    return null;\n  }\n  \n  //如果不存在管理帐号，则创建一个，并获取到userId\n  var userId = null;\n  var user = Meteor.users.findOne({username: 'admin'});\n  if(!user) {\n    userId = Meteor.users.insert({username: 'admin'});\n  } else {\n    userId = user._id;\n  }\n\n  //发送登录者的userId\n  return {\n    id: userId\n  }\n});\n```\n\n现在简单的登录函数已经写完了\n\n添加客户端的登录函数\n=================\n新建`client/admin.js`文件，将以下代码写入其中：\n```javascript\nMeteor.loginAsAdmin = function(password, callback) {\n  //新建一个带有admin:true的请求，从而让我们的登录模块来处理这个请求\n  var loginRequest = {admin: true, password: password};\n\n  //发送登录的请求\n  Accounts.callLoginMethod({\n    methodArguments: [loginRequest],\n    userCallback: callback\n  });\n};\n```\n现在我们就能添加我们的管理员登录系统。在浏览器的console界面中调用`loginAsAdmin`方法，然后你会看到你已经登录进去了\n```javascript\n//在浏览器的console中调用\nMeteor.loginAsAdmin('admin-password');\n```\n![登录成功](http://phishingw.qiniudn.com/jEa7ZJW.png)\n\n刷新浏览器\n================\n当你刷新你的浏览器的时候，你会发现你并没有继续处于登录状态。那是因为你没有在登录的时候没有添加一个记录token的功能。\n用以下的代码来更新`server/admin.js`\n```javascript\nAccounts.registerLoginHandler(function(loginRequest) {\n  if(!loginRequest.admin) {\n    return undefined;\n  }\n\n  if(loginRequest.password != 'admin-password') {\n    return null;\n  }\n  \n  var userId = null;\n  var user = Meteor.users.findOne({username: 'admin'});\n  if(!user) {\n    userId = Meteor.users.insert({username: 'admin'});\n  } else {\n    userId = user._id;\n  }\n  //以上代码无变化\n\n  //创建一个token并记录在user中\n  var stampedToken = Accounts._generateStampedLoginToken();\n  //在Meteor 0.7.x中就已经添加了对hash算法的支持 \n  //在Meteor 0.7.x之前的版本你就不需要做这样的处理\n  var hashStampedToken = Accounts._hashStampedToken(stampedToken);\n  \n  Meteor.users.update(userId, \n    {$push: {'services.resume.loginTokens': hashStampedToken}}\n  );\n\n  //把token和userId一并返回\n  return {\n    id: userId,\n    token: stampedToken.token\n  }\n});\n```\n这段代码就能解决刷新后自动退出登录状态的问题了\n\n总结\n===========================\n现在我们来总结一下我们已经做的事情\n* 我们尝试着为我们的应用做了一个管理登录系统\n* 为其添加了登录模块\n* 添加了一个客户端的登录方法\n* 添加了刷新token\n\n你可以从Github上来下载[源代码](https://github.com/arunoda/meteor-custom-authentication-system)\n这样是不是很简单的就能为Meteor应用添加一个新的认证系统货方法了？：）\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Extending-Meteor-Accounts","updated":1416449476000,"excerpt":"","_id":"eg4swt48jv5ady99","comments":true,"layout":"post","photos":[],"link":""},{"title":"Makefile的简单应用","date":1412347958000,"categories":["mord1eecial7zgj6"],"tags":["w65qo58qi878en2o","zidrwrs0jg8eyf98","9rm8mulb35wukkhr"],"content":"<h1 id=\"需求分析\">需求分析</h1>\n<p>在编写nodejs的过程中，我们经常会遇到clone一个项目后，先要键入<code>npm install</code>来安装依赖，然后运行<code>gulp</code>(因为我觉得gulp的语法很简单，所以我只会gulp，还没研究过grunt)来生成相关编译后的静态文件，再使用<code>node app</code>来运行项目</p>\n<p>这种情况如果只是一次还好，但由于nodejs在每次项目文件更改过之后，需要中断进程，然后重启进程，这个过程如果循环很多遍，相信很多人都会疯掉，虽然后类似<code>supervisor</code>之类的小工具能解决问题，<code>grunt</code>也有相应的插件能解决这个问题，例如文件改动，页面自动刷新等等，但是我这里提供了一种另外的解决方案</p>\n<h1 id=\"Makefile简介\">Makefile简介</h1>\n<p>第一次看到<code>Makefile</code>是在别人的项目中，发现很好用，主要是能少打好多个字，看了下，发现里面内容也很简单</p>\n<p>下面这个是我写的一个Makefile文件里面的内容</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"operator\"><span class=\"keyword\">install</span> : <span class=\"keyword\">all</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">all</span> :</div><div class=\"line\">\tnpm <span class=\"keyword\">install</span></div><div class=\"line\">\tgulp scripts</div><div class=\"line\">\tnode app</div></pre></figure>\n\n<p>用法很简单吧，你只需要把你要运行的命令写在all下面就好了</p>\n","source":"_posts/Makefile.md","raw":"title: Makefile的简单应用\ndate: 2014-10-03 22:52:38\ncategories: 技术\ntags: [nodejs, npm, linux]\n---\n\n需求分析\n================\n在编写nodejs的过程中，我们经常会遇到clone一个项目后，先要键入``npm install``来安装依赖，然后运行``gulp``(因为我觉得gulp的语法很简单，所以我只会gulp，还没研究过grunt)来生成相关编译后的静态文件，再使用``node app``来运行项目\n\n这种情况如果只是一次还好，但由于nodejs在每次项目文件更改过之后，需要中断进程，然后重启进程，这个过程如果循环很多遍，相信很多人都会疯掉，虽然后类似``supervisor``之类的小工具能解决问题，``grunt``也有相应的插件能解决这个问题，例如文件改动，页面自动刷新等等，但是我这里提供了一种另外的解决方案\n\nMakefile简介\n================\n\n第一次看到``Makefile``是在别人的项目中，发现很好用，主要是能少打好多个字，看了下，发现里面内容也很简单\n\n下面这个是我写的一个Makefile文件里面的内容\n```\ninstall : all\n\nall :\n\tnpm install\n\tgulp scripts\n\tnode app\n```\n\n用法很简单吧，你只需要把你要运行的命令写在all下面就好了\n","slug":"Makefile","updated":1412572984000,"excerpt":"","_id":"pc0s1dfrll2gc867","comments":true,"layout":"post","photos":[],"link":""},{"title":"Meteor中settings的设置方法","date":1412836257000,"categories":["mord1eecial7zgj6"],"tags":["ija3tw5t2s8zirjw"],"content":"<p>在Meteor的实际开发中，可能会针对不同的服务器做相关的设置，但如果每次都是改源代码会显得很麻烦，也容易出错，于是Meteor.settings就横空出世了</p>\n<p>Meteor.settings的设置很简单</p>\n<p>首先在更目录下新建一个<code>settings.json</code>文件</p>\n<p>在文件中写入</p>\n<figure class=\"highlight json\"><pre><div class=\"line\">{</div><div class=\"line\">\t\"<span class=\"attribute\">foo</span>\": <span class=\"value\"><span class=\"string\">\"bar\"</span></span></div><div class=\"line\">}</div></pre></figure>\n\n<p>然后在命令行中输入<code>meteor --settings settings.json</code>来启动项目，或者通过<code>meteor deploy --settings settings.json</code>来部署项目</p>\n<p>这样在Meteor的server端中键入<code>console.log(Meteor.settings.foo)</code>就会返回’bar’</p>\n<p>需要注意的就是，在<code>settings.json</code>中，一定要用严格的json格式，不能使用单引号，不然会出现<code>parse error reading settings file</code>的错误</p>\n<p>例如我正在写一个关于ldap的配置，具体信息如下</p>\n<figure class=\"highlight json\"><pre><div class=\"line\">{</div><div class=\"line\">\t\"<span class=\"attribute\">ldap</span>\": <span class=\"value\">{</span></div><div class=\"line\">\t    \"<span class=\"attribute\">url</span>\": <span class=\"value\"><span class=\"string\">\"ldap://my.ldapserver.com\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">base</span>\": <span class=\"value\"><span class=\"string\">\"ou=people,dc=mydomain\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">timeout</span>\": <span class=\"value\"><span class=\"number\">10000</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">bindDn</span>\": <span class=\"value\"><span class=\"string\">\"cn=admin,dc=mydomain\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">bindSecret</span>\": <span class=\"value\"><span class=\"string\">\"thesecret\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">filter</span>\": <span class=\"value\"><span class=\"string\">\"(&(uid=%uid)(objectClass=inetOrgPerson))\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">scope</span>\": <span class=\"value\"><span class=\"string\">\"one\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">nameAttribute</span>\": <span class=\"value\"><span class=\"string\">\"displayName\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">mailAttribute</span>\": <span class=\"value\"><span class=\"string\">\"mail\"</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">forceUsername</span>\": <span class=\"value\"><span class=\"literal\">true</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">throwError</span>\": <span class=\"value\"><span class=\"literal\">true</span></span>,</div><div class=\"line\">\t    \"<span class=\"attribute\">supportedServices</span>\": <span class=\"value\">[<span class=\"string\">\"cas\"</span>]</span></div><div class=\"line\">  \t}</div><div class=\"line\">}</div></pre></figure>\n\n<p>这样写之后，你用<code>meteor --settings settings.json</code>来运行，打印你的<code>Meteor.settings</code>就能看见相关设置的信息了</p>\n","source":"_posts/Meteor中settings的设置方法.md","raw":"title: Meteor中settings的设置方法\ndate: 2014-10-09 14:30:57\ncategories: 技术\ntags: Meteor\n---\n\n在Meteor的实际开发中，可能会针对不同的服务器做相关的设置，但如果每次都是改源代码会显得很麻烦，也容易出错，于是Meteor.settings就横空出世了\n\nMeteor.settings的设置很简单\n\n首先在更目录下新建一个`settings.json`文件\n\n在文件中写入\n\n```json\n{\n\t\"foo\": \"bar\"\n}\n```\n\n然后在命令行中输入`meteor --settings settings.json`来启动项目，或者通过`meteor deploy --settings settings.json`来部署项目\n\n这样在Meteor的server端中键入`console.log(Meteor.settings.foo)`就会返回'bar'\n\n需要注意的就是，在`settings.json`中，一定要用严格的json格式，不能使用单引号，不然会出现`parse error reading settings file`的错误\n\n例如我正在写一个关于ldap的配置，具体信息如下\n```json\n{\n\t\"ldap\": {\n\t    \"url\": \"ldap://my.ldapserver.com\",\n\t    \"base\": \"ou=people,dc=mydomain\",\n\t    \"timeout\": 10000,\n\t    \"bindDn\": \"cn=admin,dc=mydomain\",\n\t    \"bindSecret\": \"thesecret\",\n\t    \"filter\": \"(&(uid=%uid)(objectClass=inetOrgPerson))\",\n\t    \"scope\": \"one\",\n\t    \"nameAttribute\": \"displayName\",\n\t    \"mailAttribute\": \"mail\",\n\t    \"forceUsername\": true,\n\t    \"throwError\": true,\n\t    \"supportedServices\": [\"cas\"]\n  \t}\n}\n```\n\n这样写之后，你用`meteor --settings settings.json`来运行，打印你的`Meteor.settings`就能看见相关设置的信息了\n\n","slug":"Meteor中settings的设置方法","updated":1412836898000,"excerpt":"","_id":"phoj0gf8qiornq2s","comments":true,"layout":"post","photos":[],"link":""},{"title":"Meteor中由于活性数据造成多次调用的问题","date":1416414246000,"categories":[],"tags":[],"content":"<p>在<code>meteor</code>的开发中，我们经常会遇到一个模板的<code>helper</code>中的某一个变量的计算过程中，使用了活性数据，例如<code>Collection.find</code>、<code>Session.get(&#39;key&#39;)</code>之类的。由于这些值默认为活性数据，也就是说当这些值发生改变的时候，引用了活性数据的变量就会重新计算一次，如若这个变量逻辑很复杂，则是一件十分耗性能的事情。</p>\n<p>举个例子，我在开发过程中遇到过这种情况。我前台算好了一个数据，然后去后台订阅数据回来，我在某一个模板的<code>helper</code>中使用了<code>find</code>去查询取回来的数据，但是我的订阅是动态订阅的，所以我这个<code>helper</code>就会不停的重复调用，甚至是在我数据还没订阅回来，在订阅过程中就在不停的调用，这显然是不太好的地方。</p>\n<p>例如这样的代码</p>\n<p>client/subscribe.js</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\"><span class=\"keyword\">var</span> day = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getDay()</div><div class=\"line\">Meteor.subscribe(<span class=\"string\">'comment'</span>, {</div><div class=\"line\">\tday: day</div><div class=\"line\">})</div></pre></figure>\n\n<p>client/view/index.html</p>\n<figure class=\"highlight html\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"title\">template</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"index\"</span>&gt;</span></div><div class=\"line\">\t{{#each comments}}</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>{{content}}<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></div><div class=\"line\">\t{{/each}}</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"title\">template</span>&gt;</span></div></pre></figure>\n\n<p>client/view/index.js</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Template.index.helper({</div><div class=\"line\">\t<span class=\"string\">'comments'</span>: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> Comment.find()</div><div class=\"line\">\t}</div><div class=\"line\">})</div></pre></figure>\n\n<p>如果这个时候很不巧，正好刚刚过了零点，那么订阅的数据就会发生更改，导致<code>Comment.find</code>的值在不停的更改，就会不断触发<code>comments</code>这个<code>helper</code>在<strong>订阅数据还未完成</strong>的情况下重复计算，为了解决这样的情况，我使用了以下方法：</p>\n<p>client/subscribe.js</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\"><span class=\"keyword\">var</span> day = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getDay()</div><div class=\"line\">Meteor.isReady = Meteor.subscribe(<span class=\"string\">'comment'</span>, {</div><div class=\"line\">\tday: day</div><div class=\"line\">})</div></pre></figure>\n\n<p>client/view/index.js</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Template.index.helper({</div><div class=\"line\">\t<span class=\"string\">'comments'</span>: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">\t\t<span class=\"comment\">// 用订阅的ready状态来判断是否返回，避免正在订阅的时候也继续计算</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(Meteor.isReady.ready()) {</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> Comment.find()</div><div class=\"line\">\t\t}</div><div class=\"line\">\t}</div><div class=\"line\">})</div></pre></figure>\n\n<p>这个例子太简单，而且也没有很形象的重现出遇到的问题，在实际开发过程中，代码远比这要复杂的多，而且我在使用中会出现<code>Meteor.isReady.ready()</code>状态值不是实时更新，或没有活性跟踪的情况，不知道这是因为bug还是我的代码写的有问题，在不得已的情况下，我把上述例子改成了</p>\n<p>client/subscribe.js</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\"><span class=\"keyword\">var</span> day = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getDay()</div><div class=\"line\">Meteor.isReady = Meteor.subscribe(<span class=\"string\">'comment'</span>, {</div><div class=\"line\">\tday: day</div><div class=\"line\">})</div><div class=\"line\">Session.set(<span class=\"string\">'isReady'</span>,Meteor.isReady.ready())</div></pre></figure>\n\n<p>client/view/index.js</p>\n<figure class=\"highlight javascript\"><pre><div class=\"line\">Template.index.helper({</div><div class=\"line\">\t<span class=\"string\">'comments'</span>: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>{</div><div class=\"line\">\t\t<span class=\"comment\">// 用订阅的ready状态来判断是否返回，避免正在订阅的时候也继续计算</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(Session.get(<span class=\"string\">'isReady'</span>)) {</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> Comment.find()</div><div class=\"line\">\t\t}</div><div class=\"line\">\t}</div><div class=\"line\">})</div></pre></figure>\n\n<p>Meteor在实际开发中还是有很多问题，有无数的坑等着去填(╯‵□′)╯︵┻━┻</p>\n","source":"_posts/Meteor中由于活性数据造成多次调用的问题.md","raw":"title: Meteor中由于活性数据造成多次调用的问题\ndate: 2014-11-20 00:24:06\ncategories:\ntags:\n---\n在`meteor`的开发中，我们经常会遇到一个模板的`helper`中的某一个变量的计算过程中，使用了活性数据，例如`Collection.find`、`Session.get('key')`之类的。由于这些值默认为活性数据，也就是说当这些值发生改变的时候，引用了活性数据的变量就会重新计算一次，如若这个变量逻辑很复杂，则是一件十分耗性能的事情。\n\n举个例子，我在开发过程中遇到过这种情况。我前台算好了一个数据，然后去后台订阅数据回来，我在某一个模板的`helper`中使用了`find`去查询取回来的数据，但是我的订阅是动态订阅的，所以我这个`helper`就会不停的重复调用，甚至是在我数据还没订阅回来，在订阅过程中就在不停的调用，这显然是不太好的地方。\n\n例如这样的代码\n\nclient/subscribe.js\n```javascript\nvar day = new Date().getDay()\nMeteor.subscribe('comment', {\n\tday: day\n})\n```\n\nclient/view/index.html\n```html\n<template name=\"index\">\n\t{% raw %}{{#each comments}}{% endraw %}\n\t\t{% raw %}<p>{{content}}</p>{% endraw %}\n\t{% raw %}{{/each}}{% endraw %}\n</template>\n```\n\nclient/view/index.js\n```javascript\nTemplate.index.helper({\n\t'comments': function() {\n\t\treturn Comment.find()\n\t}\n})\n```\n\n如果这个时候很不巧，正好刚刚过了零点，那么订阅的数据就会发生更改，导致`Comment.find`的值在不停的更改，就会不断触发`comments`这个`helper`在**订阅数据还未完成**的情况下重复计算，为了解决这样的情况，我使用了以下方法：\n\nclient/subscribe.js\n```javascript\nvar day = new Date().getDay()\nMeteor.isReady = Meteor.subscribe('comment', {\n\tday: day\n})\n```\n\nclient/view/index.js\n```javascript\nTemplate.index.helper({\n\t'comments': function() {\n\t\t// 用订阅的ready状态来判断是否返回，避免正在订阅的时候也继续计算\n\t\tif(Meteor.isReady.ready()) {\n\t\t\treturn Comment.find()\n\t\t}\n\t}\n})\n```\n\n这个例子太简单，而且也没有很形象的重现出遇到的问题，在实际开发过程中，代码远比这要复杂的多，而且我在使用中会出现`Meteor.isReady.ready()`状态值不是实时更新，或没有活性跟踪的情况，不知道这是因为bug还是我的代码写的有问题，在不得已的情况下，我把上述例子改成了\n\nclient/subscribe.js\n```javascript\nvar day = new Date().getDay()\nMeteor.isReady = Meteor.subscribe('comment', {\n\tday: day\n})\nSession.set('isReady',Meteor.isReady.ready())\n```\n\nclient/view/index.js\n```javascript\nTemplate.index.helper({\n\t'comments': function() {\n\t\t// 用订阅的ready状态来判断是否返回，避免正在订阅的时候也继续计算\n\t\tif(Session.get('isReady')) {\n\t\t\treturn Comment.find()\n\t\t}\n\t}\n})\n```\n\nMeteor在实际开发中还是有很多问题，有无数的坑等着去填(╯‵□′)╯︵┻━┻\n\n","slug":"Meteor中由于活性数据造成多次调用的问题","updated":1416449897000,"excerpt":"","_id":"0a0dk934snjhr6yz","comments":true,"layout":"post","photos":[],"link":""},{"title":"git命令小记","date":1412310505000,"categories":["mord1eecial7zgj6"],"tags":["z3ade9wrlg942f7j"],"content":"<h3 id=\"简要说明\">简要说明</h3>\n<p>刚刚接触git，一直都不会用git，因为之前用的都是svn，目前正在学习nodejs，所以想把写的练习同步到github上，就查了下用法</p>\n<h3 id=\"初始化\">初始化</h3>\n<p>git的初始化是</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"variable\">$ </span>git init</div></pre></figure>\n\n<p>这样系统就在当前目录生成了一个<code>.git</code>目录</p>\n<p>首次使用<code>git</code>你可能还需要配置一下<code>git</code></p>\n<p>你可以使用以下命令来配置你<code>git</code>的常用昵称和邮箱</p>\n<figure class=\"highlight\"><pre><div class=\"line\">$ git config --global <span class=\"literal\">user</span>.name <span class=\"string\">\"Phishing\"</span></div><div class=\"line\">$ git config --global <span class=\"literal\">user</span>.email <span class=\"string\">\"yourname@xxx.com\"</span></div></pre></figure>\n\n<h3 id=\"添加文件\">添加文件</h3>\n<p>初始化以后，就需要开始添加你想要添加的文件进入git仓库了</p>\n<p>你可以使用<code>git add</code>这个命令来添加<br>例如</p>\n<figure class=\"highlight\"><pre><div class=\"line\">$ git <span class=\"built_in\">add</span> *.js</div><div class=\"line\">$ git <span class=\"built_in\">add</span> *.html</div><div class=\"line\">$ git <span class=\"built_in\">add</span> package.json</div><div class=\"line\">$ git <span class=\"built_in\">add</span> README.md</div></pre></figure>\n\n<p>这样你就把以上文件加入到了git监控的目录里面了</p>\n<p>当然在实际工作中，有些文件是不需要提交到git的</p>\n<p>你可以在当前目录中新建一个<code>.gitignore</code>文件</p>\n<p>在里面添加你不需要监控的文件</p>\n<figure class=\"highlight\"><pre><div class=\"line\">node_modules/           <span class=\"comment\">//node的包，不需要传上去，文件夹后面加一个/，代表该文件夹被忽略</span></div><div class=\"line\">/test\t\t\t\t\t<span class=\"comment\">//代表根目录下的test文件被忽略</span></div><div class=\"line\">.DS_store \t\t\t\t<span class=\"comment\">//代表.DS_store被忽略</span></div></pre></figure>\n\n<p>查看当前git的状态可以使用<code>git status</code></p>\n<p>如果你没有添加上面的.gitignore的话，输入<code>git status</code>，git就会用红色高亮告诉你这几个文件是没有被加入git的监控中的，如果需要就使用<code>git add &lt;filename&gt;</code>来添加<br>加了.gitignore后，就不会再提示</p>\n<h3 id=\"提交代码\">提交代码</h3>\n<p>文件添加成功后，就可以开始提交代码了</p>\n<p>可以使用<code>git commit</code>来提交代码到git仓库中</p>\n<p>如果之间键入<code>git commit</code>会提示你没有添加提交massage，你可以在弹出的文件中键入提交信息，然后退出编辑器，即自动提交</p>\n<p>当然这样可能会有点麻烦，所以你可以利用<code>git commit -m &#39;your massage&#39;</code>来在命令行中直接写入提交的信息</p>\n<p>输入完后，git就会告诉你你当前git仓库里面的状态了</p>\n<p>刚刚开始接触git的时候，我每改动一个文件，然后用<code>git status</code>来查看过后发现，我需要再键入一遍<code>git add &lt;filename&gt;</code>才能提交，这让我感觉非常麻烦</p>\n<p>后来我终于知道有个快捷方式了，就是<code>git commit -a -m &#39;your massage&#39;</code>，这样就能跳过<code>git add</code>这个步骤了，当然这样有好有坏，我就不细说了</p>\n<h3 id=\"提交代码到远程仓库\">提交代码到远程仓库</h3>\n<p>提交代码到远程仓库时，你首先得新建一个<code>ssh key</code>，<a href=\"https://help.github.com/articles/generating-ssh-keys/\" target=\"_blank\" rel=\"external\">具体方法在这里</a></p>\n<p>弄好ssh key之后，就可以使用</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"variable\">$ </span>git remote origin <span class=\"symbol\">git:</span>/<span class=\"regexp\">/your_github_address/your</span>_repositores_name.git</div></pre></figure>\n\n<p>来定义远程仓库的地址了</p>\n<p>定义好之后就能使用</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"variable\">$ </span>git push</div></pre></figure>\n\n<p>来提交代码到远程仓库了</p>\n<p>如果你是第一次提交代码，系统会提示你使用</p>\n<figure class=\"highlight\"><pre><div class=\"line\">$ git <span class=\"keyword\">push</span> --<span class=\"keyword\">set</span>-upstream origin master</div></pre></figure>\n\n<p>来提交代码</p>\n<p>以后你就可以修改代码然后使用</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"variable\">$ </span>git commit -a -m <span class=\"string\">'your massage'</span></div><div class=\"line\"><span class=\"variable\">$ </span>git push</div></pre></figure>\n\n<p>来提交你的代码了：）</p>\n<h3 id=\"最后\">最后</h3>\n<p>以上就是我这刚刚接触git的小白了解到的一些git的基本操作了，如有错误，还请指出</p>\n<p>谢谢观看【捂脸下台</p>\n","source":"_posts/git命令小记.md","raw":"title: git命令小记\ndate: 2014-10-03 12:28:25\ncategories: 技术\ntags: git\n---\n\n###简要说明\n\n刚刚接触git，一直都不会用git，因为之前用的都是svn，目前正在学习nodejs，所以想把写的练习同步到github上，就查了下用法\n\n###初始化\ngit的初始化是\n```\n$ git init\n```\n这样系统就在当前目录生成了一个``.git``目录\n\n首次使用``git``你可能还需要配置一下``git``\n\n你可以使用以下命令来配置你``git``的常用昵称和邮箱\n```\n$ git config --global user.name \"Phishing\"\n$ git config --global user.email \"yourname@xxx.com\"\n```\n\n###添加文件\n\n初始化以后，就需要开始添加你想要添加的文件进入git仓库了\n\n你可以使用``git add``这个命令来添加\n例如\n```\n$ git add *.js\n$ git add *.html\n$ git add package.json\n$ git add README.md\n```\n\n这样你就把以上文件加入到了git监控的目录里面了\n\n当然在实际工作中，有些文件是不需要提交到git的\n\n你可以在当前目录中新建一个``.gitignore``文件\n\n在里面添加你不需要监控的文件\n```\nnode_modules/           //node的包，不需要传上去，文件夹后面加一个/，代表该文件夹被忽略\n/test\t\t\t\t\t//代表根目录下的test文件被忽略\n.DS_store \t\t\t\t//代表.DS_store被忽略\n```\n查看当前git的状态可以使用``git status``\n\n如果你没有添加上面的.gitignore的话，输入``git status``，git就会用红色高亮告诉你这几个文件是没有被加入git的监控中的，如果需要就使用``git add <filename>``来添加\n加了.gitignore后，就不会再提示\n\n###提交代码\n\n文件添加成功后，就可以开始提交代码了\n\n可以使用``git commit``来提交代码到git仓库中\n\n如果之间键入``git commit``会提示你没有添加提交massage，你可以在弹出的文件中键入提交信息，然后退出编辑器，即自动提交\n\n当然这样可能会有点麻烦，所以你可以利用``git commit -m 'your massage'``来在命令行中直接写入提交的信息\n\n输入完后，git就会告诉你你当前git仓库里面的状态了\n\n刚刚开始接触git的时候，我每改动一个文件，然后用``git status``来查看过后发现，我需要再键入一遍``git add <filename>``才能提交，这让我感觉非常麻烦\n\n后来我终于知道有个快捷方式了，就是``git commit -a -m 'your massage'``，这样就能跳过``git add``这个步骤了，当然这样有好有坏，我就不细说了\n\n###提交代码到远程仓库\n\n提交代码到远程仓库时，你首先得新建一个``ssh key``，[具体方法在这里](https://help.github.com/articles/generating-ssh-keys/)\n\n弄好ssh key之后，就可以使用\n\n```\n$ git remote origin git://your_github_address/your_repositores_name.git\n```\n\n来定义远程仓库的地址了\n\n定义好之后就能使用\n```\n$ git push\n```\n来提交代码到远程仓库了\n\n如果你是第一次提交代码，系统会提示你使用\n```\n$ git push --set-upstream origin master\n```\n来提交代码\n\n以后你就可以修改代码然后使用\n```\n$ git commit -a -m 'your massage'\n$ git push\n```\n来提交你的代码了：）\n\n###最后\n\n以上就是我这刚刚接触git的小白了解到的一些git的基本操作了，如有错误，还请指出\n\n谢谢观看【捂脸下台\n\n\n\n\n\n\n","slug":"git命令小记","updated":1412572978000,"excerpt":"","_id":"03wskzpff7rowk0r","comments":true,"layout":"post","photos":[],"link":""},{"title":"关于在Meteor中写自定义登录需要注意的地方","date":1413209946000,"categories":["mord1eecial7zgj6"],"tags":["ija3tw5t2s8zirjw"],"content":"<p>上一篇博文翻译了Meteorhack的一篇关于如何编写自定义登录方式之后，对<code>Meteor</code>的’Accounts’模块有了一定的认识，为在实际工作中提供了理论知识</p>\n<p>通过这几天在编写自定义登录模块的摸爬滚打之后，也逐渐开始遇到了一些问题</p>\n<h1 id=\"问题一———-第三方登录和原有登录系统冲突\">问题一———-第三方登录和原有登录系统冲突</h1>\n<p>我在编写登录模块的时候，由于系统本身已经添加了<code>accounts-password</code>包，在编写我自己的<code>registerLoginHandler</code>之后，会优先去执行<code>accounts-password</code>包里面的函数，导致每次我调用登录模块，换来的都是<code>Match failed</code>的错误</p>\n<p>我通过查看<code>accounts-password</code>包的<a href=\"https://github.com/meteor/meteor/blob/devel/packages%2Faccounts-password%2Fpassword_server.js#L140\" target=\"_blank\" rel=\"external\">源码</a>之后，我发现，<code>accounts-password</code>的登录逻辑里，会判断传入的<code>loginRequest</code>中是否含有<code>password</code>和<code>srp</code>，在0.8.1之前你只能用密码登录，所以提供了一种登录方法，在0.8.1之后，你还可以使用<code>srp</code>来登录，所以<code>Meteor</code>又写了另外一种登录方法</p>\n<p>通过查看发现，是否调用<code>accounts-password</code>的关键在于，你是否传递了<code>password</code>和<code>srp</code>，通过改进后，我把<code>loginRequest</code>传入的key从<code>password</code>更改成了<code>ldap_password</code>，更改之后，就能绕过<code>accounts-password</code>包的登录机制了</p>\n<h1 id=\"问题二————-关于调用Accounts-callLoginMethod方法中的methodName\">问题二————-关于调用Accounts.callLoginMethod方法中的methodName</h1>\n<p>这个问题一直困扰我，我在<code>registerLoginHandler</code>的时候，给我的method声明了名称，但是在实际调用中，我给<code>Accounts.callLoginMethod</code>传递了<code>methodName</code>却提示我<code>method not found</code>的错误，这问题有待解决</p>\n<p>先只写这么多，等我第三方登录模块写完之后，应该会写一个介绍<code>ldapjs</code>的博文</p>\n","source":"_posts/关于在Meteor中写自定义登录需要注意的地方.md","raw":"title: 关于在Meteor中写自定义登录需要注意的地方\ndate: 2014-10-13 22:19:06\ncategories: 技术\ntags: Meteor\n---\n\n上一篇博文翻译了Meteorhack的一篇关于如何编写自定义登录方式之后，对`Meteor`的'Accounts'模块有了一定的认识，为在实际工作中提供了理论知识\n\n通过这几天在编写自定义登录模块的摸爬滚打之后，也逐渐开始遇到了一些问题\n\n问题一-------第三方登录和原有登录系统冲突\n==========================\n我在编写登录模块的时候，由于系统本身已经添加了`accounts-password`包，在编写我自己的`registerLoginHandler`之后，会优先去执行`accounts-password`包里面的函数，导致每次我调用登录模块，换来的都是`Match failed`的错误\n\n我通过查看`accounts-password`包的[源码](https://github.com/meteor/meteor/blob/devel/packages%2Faccounts-password%2Fpassword_server.js#L140)之后，我发现，`accounts-password`的登录逻辑里，会判断传入的`loginRequest`中是否含有`password`和`srp`，在0.8.1之前你只能用密码登录，所以提供了一种登录方法，在0.8.1之后，你还可以使用`srp`来登录，所以`Meteor`又写了另外一种登录方法\n\n通过查看发现，是否调用`accounts-password`的关键在于，你是否传递了`password`和`srp`，通过改进后，我把`loginRequest`传入的key从`password`更改成了`ldap_password`，更改之后，就能绕过`accounts-password`包的登录机制了\n\n问题二---------关于调用Accounts.callLoginMethod方法中的methodName\n=======================\n这个问题一直困扰我，我在`registerLoginHandler`的时候，给我的method声明了名称，但是在实际调用中，我给`Accounts.callLoginMethod`传递了`methodName`却提示我`method not found`的错误，这问题有待解决\n\n\n\n先只写这么多，等我第三方登录模块写完之后，应该会写一个介绍`ldapjs`的博文","slug":"关于在Meteor中写自定义登录需要注意的地方","updated":1413213673000,"excerpt":"","_id":"f989donotfg9jkp6","comments":true,"layout":"post","photos":[],"link":""},{"title":"简单解析formidable's API","date":1413432065000,"categories":["mord1eecial7zgj6"],"tags":["w65qo58qi878en2o"],"content":"<p>本文翻译自<code>github</code>上的<a href=\"https://github.com/felixge/node-formidable#events\" target=\"_blank\" rel=\"external\">Formidable的官方页面</a></p>\n<h1 id=\"介绍\">介绍</h1>\n<p>一个用来解析数据，特别是上传数据的nodejs模块</p>\n<h1 id=\"安装\">安装</h1>\n<p>这是一个底层的包，如果你使用的是一个高级的类似<code>Express</code>的框架，你可以通过阅读<a href=\"http://stackoverflow.com/questions/11295554/how-to-disable-express-bodyparser-for-file-uploads-node-js\" target=\"_blank\" rel=\"external\">这里</a>来了解如何在<code>Express</code>来使用<code>Formidable</code>。</p>\n<p>你可以使用<code>npm</code>来安装:</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"built_in\">npm</span> install formidable<span class=\"property\">@latest</span></div></pre></figure>\n\n<p>或者手动安装：</p>\n<figure class=\"highlight\"><pre><div class=\"line\">git clone gi<span class=\"variable\">t:</span>//github.<span class=\"keyword\">com</span>/felixge/node-formidable.git formidable</div><div class=\"line\"><span class=\"keyword\">vim</span> my.js</div><div class=\"line\"># var formidable = require(<span class=\"string\">'./formidable'</span>);</div></pre></figure>\n\n<p>注意：Formidable应用了<a href=\"http://github.com/felixge/node-gently\" target=\"_blank\" rel=\"external\">gently</a>来运行单元测试，但是你没必要使用它</p>\n<h1 id=\"例子\">例子</h1>\n<p>解析一个文件上传</p>\n<figure class=\"highlight\"><pre><div class=\"line\">var formidable = require(<span class=\"string\">'formidable'</span>),</div><div class=\"line\">    http = require(<span class=\"string\">'http'</span>),</div><div class=\"line\">    util = require(<span class=\"string\">'util'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"transposed_variable\">http.</span>createServer(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(req, res)</span> {</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"transposed_variable\">req.</span>url == <span class=\"string\">'/upload'</span> && <span class=\"transposed_variable\">req.</span><span class=\"transposed_variable\">method.</span>toLowerCase() == <span class=\"string\">'post'</span>) {</div><div class=\"line\">    <span class=\"comment\">// 解析文件上传</span></div><div class=\"line\">    var form = new <span class=\"transposed_variable\">formidable.</span>IncomingForm();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"transposed_variable\">form.</span>parse(req, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(err, fields, files)</span> {</span></div><div class=\"line\">      <span class=\"transposed_variable\">res.</span>writeHead(<span class=\"number\">200</span>, {<span class=\"string\">'content-type'</span>: <span class=\"string\">'text/plain'</span>});</div><div class=\"line\">      <span class=\"transposed_variable\">res.</span>write(<span class=\"string\">'received upload:\\n\\n'</span>);</div><div class=\"line\">      <span class=\"transposed_variable\">res.</span><span class=\"keyword\">end</span>(<span class=\"transposed_variable\">util.</span>inspect({fields: fields, files: files}));</div><div class=\"line\">    });</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  }</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 展示一个文件上传表单</span></div><div class=\"line\">  <span class=\"transposed_variable\">res.</span>writeHead(<span class=\"number\">200</span>, {<span class=\"string\">'content-type'</span>: <span class=\"string\">'text/html'</span>});</div><div class=\"line\">  <span class=\"transposed_variable\">res.</span><span class=\"keyword\">end</span>(</div><div class=\"line\">    <span class=\"string\">'&lt;form action=\"</span>/upload<span class=\"string\">\" enctype=\"</span>multipart/form-data<span class=\"string\">\" method=\"</span>post<span class=\"string\">\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"</span>text<span class=\"string\">\" name=\"</span>title<span class=\"string\">\"&gt;&lt;br&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"</span>file<span class=\"string\">\" name=\"</span>upload<span class=\"string\">\" multiple=\"</span>multiple<span class=\"string\">\"&gt;&lt;br&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;input type=\"</span>submit<span class=\"string\">\" value=\"</span>Upload<span class=\"string\">\"&gt;'</span>+</div><div class=\"line\">    <span class=\"string\">'&lt;/form&gt;'</span></div><div class=\"line\">  );</div><div class=\"line\">}).listen(<span class=\"number\">8080</span>);</div></pre></figure>\n\n<h1 id=\"API\">API</h1>\n<h3 id=\"Formidable-IncomingForm\">Formidable.IncomingForm</h3>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"keyword\">var</span> form = <span class=\"keyword\">new</span> formidable.IncomingForm()</div></pre></figure>\n\n<p>新建一个传入表单的对象</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.encoding = <span class=\"string\">'utf-8'</span></div></pre></figure>\n\n<p>设置上传表单域的编码</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.uploadDir = <span class=\"string\">'/my/dir'</span></div></pre></figure>\n\n<p>设置文件上传的目录，稍后你可以使用<code>fs.rename()</code>来更改它。默认值为<code>os.tmpDir()</code>。</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"variable\">keepExtensions =</span> <span class=\"constant\">false</span></div></pre></figure>\n\n<p>如果你想上传的文件保留扩展名，把这一项设置为<code>true</code></p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"title\">form</span>.<span class=\"typedef\"><span class=\"keyword\">type</span></span></div></pre></figure>\n\n<p>根据请求来判断的编码类型</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.maxFieldsSize = 2 <span class=\"keyword\">*</span> 1024 <span class=\"keyword\">*</span> 1024</div></pre></figure>\n\n<p>限制分配给处理域的内存大小，如果分配的值超过这个数值，则<code>error</code>时间将会被触发，默认值为2MB。</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"attribute\">form.maxFields </span>=<span class=\"string\"> 1000</span></div></pre></figure>\n\n<p>限制域中解码查询语句的个数。默认值为1000</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"variable\">hash =</span> <span class=\"constant\">false</span></div></pre></figure>\n\n<p>如果你想对传入的文件进行校验，请设置该属性为<code>sha1</code>或者<code>md5</code></p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"variable\">multiples =</span> <span class=\"constant\">false</span></div></pre></figure>\n\n<p>开启这个选项后，你就能使用HTML5的多文件上传功能了，调用<code>form.parse</code>时传入的就是一个文件的数组</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.bytesReceived</div></pre></figure>\n\n<p>从表单获取到的字节数</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.bytesExpected</div></pre></figure>\n\n<p>预计还剩的字节数</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.parse(request, [<span class=\"keyword\">cb</span>])</div></pre></figure>\n\n<p>从一个node.js上传请求数据中解析内容。如果有<code>cb</code>传入，所有的文件和请求将会传递到这个callback,例如:</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.parse(req, <span class=\"keyword\">function</span>(err, fields, files) {</div><div class=\"line\">\t// <span class=\"keyword\">...</span></div><div class=\"line\">});</div><div class=\"line\"></div><div class=\"line\">form.onPart(part);</div></pre></figure>\n\n<p>如果你想直接访问<code>multipart stream</code>，你可以覆盖掉这个方法。但是这么做之后会禁用掉<code>field</code>/<code>file</code>事件处理。</p>\n<p>如果你想用Formidable来处理某些文件，你可以这么做：</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.onPart = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(part)</span> </span>{</div><div class=\"line\">  <span class=\"keyword\">if</span> (!part.filename) {</div><div class=\"line\">    <span class=\"comment\">// let formidable handle all non-file parts</span></div><div class=\"line\">    form.handlePart(part);</div><div class=\"line\">  }</div><div class=\"line\">}</div></pre></figure>\n\n<h3 id=\"Formidable-File\">Formidable.File</h3>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"keyword\">file</span>.<span class=\"keyword\">size</span> = <span class=\"number\">0</span></div></pre></figure>\n\n<p>上传文件的大小，单位是bytes，如果文件还在上传中（如在<code>fileBegin</code>事件中）,这个数值将会告诉你有多少字节被写入了硬盘</p>\n<figure class=\"highlight\"><pre><div class=\"line\">file.<span class=\"variable\">path =</span> <span class=\"constant\">null</span></div></pre></figure>\n\n<p>当前文件的被写入的路径。如果你不想把你的文件放入设置的公共路径，你可以在<code>fileBegin</code>事件中更改这个值</p>\n<figure class=\"highlight\"><pre><div class=\"line\">file.<span class=\"variable\">name =</span> <span class=\"constant\">null</span></div></pre></figure>\n\n<p>根据客户端获取到的文件上传后的名字</p>\n<figure class=\"highlight\"><pre><div class=\"line\"><span class=\"keyword\">file</span>.<span class=\"keyword\">type</span> = <span class=\"keyword\">null</span></div></pre></figure>\n\n<p>根据客户端获取到的文件上传后的<code>mine</code>类型</p>\n<figure class=\"highlight\"><pre><div class=\"line\">file.<span class=\"variable\">lastModifiedDate =</span> <span class=\"constant\">null</span></div></pre></figure>\n\n<p>文件最后被更改的时间对象</p>\n<figure class=\"highlight\"><pre><div class=\"line\">file.<span class=\"variable\">hash =</span> <span class=\"constant\">null</span></div></pre></figure>\n\n<p>得到经过hash计算后的十六进制值</p>\n<h4 id=\"Formidable-File#toJSON()\">Formidable.File#toJSON()</h4>\n<p>这个方法返回一个表示文件的JSON数据，可以使用<code>JSON.stringify()</code>来使用它去记录日志或者响应请求</p>\n<h1 id=\"事件\">事件</h1>\n<h4 id=\"‘progress’\">‘progress’</h4>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'progress'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(bytesReceived, bytesExpected)</span> <span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<p>发生在每一个数据传入的块被解析之后，可以用来实现进度条</p>\n<h4 id=\"‘field’\">‘field’</h4>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'field'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(name, value)</span> <span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<h4 id=\"‘fileBegin’\">‘fileBegin’</h4>\n<p>每当一个域或者键值对被接受到的时候</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'fileBegin'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(name, <span class=\"keyword\">file</span>)</span> <span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<h4 id=\"‘file’\">‘file’</h4>\n<p>当一个新的文件在上传流中被检测到的时候触发。 Use this even if you want to stream the file to somewhere else while buffering the upload on the file system.(没理解T_T)</p>\n<p>每当一个文件被接收的时候触发，<code>file</code>是<code>File</code>的实例</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'file'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(name, <span class=\"keyword\">file</span>)</span> <span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<h4 id=\"‘error’\">‘error’</h4>\n<p>当有表单处理错误的时候触发，请求会自动暂停，如果你需要继续触发<code>data</code>事件，你需要手动调用<code>request.resume()</code></p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(err)</span> <span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<h4 id=\"‘aborted’\">‘aborted’</h4>\n<p>当用户使请求终止的时候触发，现在这个事件是由<code>socket</code>的<code>close</code>和<code>timeout</code>共同触发的，将来会把<code>timeout</code>给独立出来(这需要更改node的核心)。</p>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'aborted'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span><span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<h4 id=\"‘end’\">‘end’</h4>\n<figure class=\"highlight\"><pre><div class=\"line\">form.<span class=\"keyword\">on</span>(<span class=\"string\">'end'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"comment\">{</span></span></div><div class=\"line\">});</div></pre></figure>\n\n<p>当整个请求被接收完并写入磁盘后触发。这里就是你返回数据的一个好地方。</p>\n<h1 id=\"译者注\">译者注</h1>\n<p>小白前端一枚，对该模块不了解的情况下翻译，本意是为了辅助自己更好的理解该模块，如有错误，请指出，谢谢。</p>\n","source":"_posts/简单解析formidable-s-API.md","raw":"title: 简单解析formidable's API\ndate: 2014-10-16 12:01:05\ncategories: 技术\ntags: nodejs\n---\n\n本文翻译自`github`上的[Formidable的官方页面](https://github.com/felixge/node-formidable#events)\n\n介绍\n=================\n一个用来解析数据，特别是上传数据的nodejs模块\n\n安装\n=========\n这是一个底层的包，如果你使用的是一个高级的类似`Express`的框架，你可以通过阅读[这里](http://stackoverflow.com/questions/11295554/how-to-disable-express-bodyparser-for-file-uploads-node-js)来了解如何在`Express`来使用`Formidable`。\n\n你可以使用`npm`来安装:\n```\nnpm install formidable@latest\n```\n\n或者手动安装：\n```\ngit clone git://github.com/felixge/node-formidable.git formidable\nvim my.js\n# var formidable = require('./formidable');\n```\n\n注意：Formidable应用了[gently](http://github.com/felixge/node-gently)来运行单元测试，但是你没必要使用它\n\n例子\n===========\n解析一个文件上传\n```\nvar formidable = require('formidable'),\n    http = require('http'),\n    util = require('util');\n\nhttp.createServer(function(req, res) {\n  if (req.url == '/upload' && req.method.toLowerCase() == 'post') {\n    // 解析文件上传\n    var form = new formidable.IncomingForm();\n\n    form.parse(req, function(err, fields, files) {\n      res.writeHead(200, {'content-type': 'text/plain'});\n      res.write('received upload:\\n\\n');\n      res.end(util.inspect({fields: fields, files: files}));\n    });\n\n    return;\n  }\n\n  // 展示一个文件上传表单\n  res.writeHead(200, {'content-type': 'text/html'});\n  res.end(\n    '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n    '<input type=\"text\" name=\"title\"><br>'+\n    '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n    '<input type=\"submit\" value=\"Upload\">'+\n    '</form>'\n  );\n}).listen(8080);\n```\n\nAPI\n==============\n### Formidable.IncomingForm\n\n```\nvar form = new formidable.IncomingForm()\n```\n新建一个传入表单的对象\n\n```\nform.encoding = 'utf-8'\n```\n设置上传表单域的编码\n\n```\nform.uploadDir = '/my/dir'\n```\n设置文件上传的目录，稍后你可以使用`fs.rename()`来更改它。默认值为`os.tmpDir()`。\n\n```\nform.keepExtensions = false\n```\n如果你想上传的文件保留扩展名，把这一项设置为`true`\n\n```\nform.type\n```\n根据请求来判断的编码类型\n\n```\nform.maxFieldsSize = 2 * 1024 * 1024\n```\n限制分配给处理域的内存大小，如果分配的值超过这个数值，则`error`时间将会被触发，默认值为2MB。\n\n```\nform.maxFields = 1000\n```\n限制域中解码查询语句的个数。默认值为1000\n\n```\nform.hash = false\n```\n如果你想对传入的文件进行校验，请设置该属性为`sha1`或者`md5`\n\n```\nform.multiples = false\n```\n开启这个选项后，你就能使用HTML5的多文件上传功能了，调用`form.parse`时传入的就是一个文件的数组\n\n```\nform.bytesReceived\n```\n从表单获取到的字节数\n\n```\nform.bytesExpected\n```\n预计还剩的字节数\n\n```\nform.parse(request, [cb])\n```\n从一个node.js上传请求数据中解析内容。如果有`cb`传入，所有的文件和请求将会传递到这个callback,例如:\n```\nform.parse(req, function(err, fields, files) {\n\t// ...\n});\n\nform.onPart(part);\n```\n如果你想直接访问`multipart stream`，你可以覆盖掉这个方法。但是这么做之后会禁用掉`field`/`file`事件处理。\n\n如果你想用Formidable来处理某些文件，你可以这么做：\n```\nform.onPart = function(part) {\n  if (!part.filename) {\n    // let formidable handle all non-file parts\n    form.handlePart(part);\n  }\n}\n```\n\n###Formidable.File\n```\nfile.size = 0\n```\n上传文件的大小，单位是bytes，如果文件还在上传中（如在`fileBegin`事件中）,这个数值将会告诉你有多少字节被写入了硬盘\n\n```\nfile.path = null\n```\n当前文件的被写入的路径。如果你不想把你的文件放入设置的公共路径，你可以在`fileBegin`事件中更改这个值\n\n```\nfile.name = null\n```\n根据客户端获取到的文件上传后的名字\n\n```\nfile.type = null\n```\n根据客户端获取到的文件上传后的`mine`类型\n```\nfile.lastModifiedDate = null\n```\n文件最后被更改的时间对象\n\n```\nfile.hash = null\n```\n得到经过hash计算后的十六进制值\n\n####Formidable.File#toJSON()\n这个方法返回一个表示文件的JSON数据，可以使用`JSON.stringify()`来使用它去记录日志或者响应请求\n\n事件\n===========\n####'progress'\n```\nform.on('progress', function(bytesReceived, bytesExpected) {\n});\n```\n发生在每一个数据传入的块被解析之后，可以用来实现进度条\n####'field'\n```\nform.on('field', function(name, value) {\n});\n```\n####'fileBegin'\n每当一个域或者键值对被接受到的时候\n```\nform.on('fileBegin', function(name, file) {\n});\n```\n\n####'file'\n当一个新的文件在上传流中被检测到的时候触发。 Use this even if you want to stream the file to somewhere else while buffering the upload on the file system.(没理解T_T)\n\n每当一个文件被接收的时候触发，`file`是`File`的实例\n```\nform.on('file', function(name, file) {\n});\n```\n####'error'\n当有表单处理错误的时候触发，请求会自动暂停，如果你需要继续触发`data`事件，你需要手动调用`request.resume()`\n```\nform.on('error', function(err) {\n});\n```\n####'aborted'\n当用户使请求终止的时候触发，现在这个事件是由`socket`的`close`和`timeout`共同触发的，将来会把`timeout`给独立出来(这需要更改node的核心)。\n```\nform.on('aborted', function(){\n});\n```\n####'end'\n```\nform.on('end',function() {\n});\n```\n当整个请求被接收完并写入磁盘后触发。这里就是你返回数据的一个好地方。\n\n译者注\n======\n小白前端一枚，对该模块不了解的情况下翻译，本意是为了辅助自己更好的理解该模块，如有错误，请指出，谢谢。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"简单解析formidable-s-API","updated":1416449476000,"excerpt":"","_id":"169d3b4ms3mnbh19","comments":true,"layout":"post","photos":[],"link":""},{"title":"npm网速慢的解决办法","date":1411917751000,"categories":["mord1eecial7zgj6"],"tags":["zidrwrs0jg8eyf98","w65qo58qi878en2o"],"content":"<p>国内经常会遇到npm特别慢的情况，可以通过下面的方式，更改npm的镜像</p>\n<h3 id=\"通过下面命令设置镜像\">通过下面命令设置镜像</h3>\n<p><code>npm config set registry http://r.cnpmjs.org</code></p>\n<p>国内镜像：</p>\n<blockquote>\n<p><a href=\"http://r.cnpmjs.org\" target=\"_blank\" rel=\"external\">http://r.cnpmjs.org</a><br><a href=\"http://registry.cnpmjs.org\" target=\"_blank\" rel=\"external\">http://registry.cnpmjs.org</a><br><a href=\"http://registry.npm.taobao.org\" target=\"_blank\" rel=\"external\">http://registry.npm.taobao.org</a></p>\n</blockquote>\n<p>官方镜像：</p>\n<blockquote>\n<p><a href=\"https://registry.npmjs.org\" target=\"_blank\" rel=\"external\">https://registry.npmjs.org</a></p>\n</blockquote>\n<h3 id=\"常用的npm的命令\">常用的npm的命令</h3>\n<p><code>npm install -g</code>全局安装包<br><code>npm ls -g</code>   查看全局已安装的包<br><code>npm install &lt;package&gt;@&lt;version&gt;</code>安装指定版本的包</p>\n<h3 id=\"附上常用的库的地址\">附上常用的库的地址</h3>\n<p>JQuery地址</p>\n<blockquote>\n<p><a href=\"http://code.jquery.com/jquery-1.11.0.min.js\" target=\"_blank\" rel=\"external\">http://code.jquery.com/jquery-1.11.0.min.js</a></p>\n</blockquote>\n<p>bootstrapev2地址</p>\n<blockquote>\n<p><a href=\"http://cdn.bootcss.com/twitter-bootstrap/2.3.2/css/bootstrap.min.css\" target=\"_blank\" rel=\"external\">http://cdn.bootcss.com/twitter-bootstrap/2.3.2/css/bootstrap.min.css</a><br><a href=\"http://cdn.bootcss.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js\" target=\"_blank\" rel=\"external\">http://cdn.bootcss.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js</a></p>\n</blockquote>\n","source":"_posts/npm网速慢的解决办法.md","raw":"title: npm网速慢的解决办法\ndate: 2014-09-28 23:22:31\ncategories: 技术\ntags: [npm, nodejs]\n---\n\n国内经常会遇到npm特别慢的情况，可以通过下面的方式，更改npm的镜像\n\n###通过下面命令设置镜像\n``npm config set registry http://r.cnpmjs.org``\n\n国内镜像：\n>http://r.cnpmjs.org\n>http://registry.cnpmjs.org \n>http://registry.npm.taobao.org\n\n官方镜像：\n>https://registry.npmjs.org\n\n###常用的npm的命令\n``npm install -g``全局安装包\n``npm ls -g``   查看全局已安装的包\n``npm install <package>@<version>``安装指定版本的包\n\n\n###附上常用的库的地址\n\nJQuery地址\n>http://code.jquery.com/jquery-1.11.0.min.js\n\nbootstrapev2地址\n>http://cdn.bootcss.com/twitter-bootstrap/2.3.2/css/bootstrap.min.css\n>http://cdn.bootcss.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js\n\n\n","slug":"npm网速慢的解决办法","updated":1411958621000,"excerpt":"","_id":"jwpm3npbj3epzshe","comments":true,"layout":"post","photos":[],"link":""}],"Tag":[{"name":"Meteor","_id":"ija3tw5t2s8zirjw","posts":["eg4swt48jv5ady99","phoj0gf8qiornq2s","f989donotfg9jkp6"]},{"name":"nodejs","_id":"w65qo58qi878en2o","posts":["pc0s1dfrll2gc867","169d3b4ms3mnbh19","jwpm3npbj3epzshe"]},{"name":"npm","_id":"zidrwrs0jg8eyf98","posts":["pc0s1dfrll2gc867","jwpm3npbj3epzshe"]},{"name":"linux","_id":"9rm8mulb35wukkhr","posts":["pc0s1dfrll2gc867"]},{"name":"git","_id":"z3ade9wrlg942f7j","posts":["03wskzpff7rowk0r"]}]}